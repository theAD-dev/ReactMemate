{"version":3,"file":"static/js/79.43d41e4b.chunk.js","mappings":"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","sources":["../node_modules/primereact/chart/chart.esm.js","../node_modules/react-bootstrap-icons/dist/icons/calendar.js","../node_modules/react-bootstrap-icons/dist/icons/clipboard-data.js","../node_modules/react-bootstrap-icons/dist/icons/google.js","../node_modules/react-bootstrap-icons/dist/icons/pie-chart.js","../node_modules/react-bootstrap-icons/dist/icons/speedometer2.js","../node_modules/react-bootstrap-icons/dist/icons/text-paragraph.js","../node_modules/react-bootstrap-icons/dist/icons/window-desktop.js","../node_modules/chart.js/src/core/core.animator.js","../node_modules/chart.js/src/core/core.animation.js","../node_modules/chart.js/src/core/core.animations.js","../node_modules/chart.js/src/core/core.datasetController.js","../node_modules/chart.js/src/controllers/controller.bar.js","../node_modules/chart.js/src/controllers/controller.bubble.js","../node_modules/chart.js/src/controllers/controller.doughnut.js","../node_modules/chart.js/src/controllers/controller.line.js","../node_modules/chart.js/src/controllers/controller.polarArea.js","../node_modules/chart.js/src/controllers/controller.pie.js","../node_modules/chart.js/src/controllers/controller.radar.js","../node_modules/chart.js/src/controllers/controller.scatter.js","../node_modules/chart.js/src/core/core.adapters.ts","../node_modules/chart.js/src/core/core.interaction.js","../node_modules/chart.js/src/core/core.layouts.js","../node_modules/chart.js/src/platform/platform.base.js","../node_modules/chart.js/src/platform/platform.basic.js","../node_modules/chart.js/src/platform/platform.dom.js","../node_modules/chart.js/src/platform/index.js","../node_modules/chart.js/src/core/core.element.ts","../node_modules/chart.js/src/core/core.scale.autoskip.js","../node_modules/chart.js/src/core/core.scale.js","../node_modules/chart.js/src/core/core.typedRegistry.js","../node_modules/chart.js/src/core/core.registry.js","../node_modules/chart.js/src/core/core.plugins.js","../node_modules/chart.js/src/core/core.config.js","../node_modules/chart.js/src/core/core.controller.js","../node_modules/chart.js/src/elements/element.arc.ts","../node_modules/chart.js/src/elements/element.line.js","../node_modules/chart.js/src/elements/element.point.ts","../node_modules/chart.js/src/elements/element.bar.js","../node_modules/chart.js/src/plugins/plugin.colors.ts","../node_modules/chart.js/src/plugins/plugin.decimation.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.segment.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.helper.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.options.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.target.stack.js","../node_modules/chart.js/src/plugins/plugin.filler/simpleArc.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.target.js","../node_modules/chart.js/src/plugins/plugin.filler/filler.drawing.js","../node_modules/chart.js/src/plugins/plugin.filler/index.js","../node_modules/chart.js/src/plugins/plugin.legend.js","../node_modules/chart.js/src/plugins/plugin.title.js","../node_modules/chart.js/src/plugins/plugin.subtitle.js","../node_modules/chart.js/src/plugins/plugin.tooltip.js","../node_modules/chart.js/src/scales/scale.category.js","../node_modules/chart.js/src/scales/scale.linearbase.js","../node_modules/chart.js/src/scales/scale.linear.js","../node_modules/chart.js/src/scales/scale.logarithmic.js","../node_modules/chart.js/src/scales/scale.radialLinear.js","../node_modules/chart.js/src/scales/scale.time.js","../node_modules/chart.js/src/scales/scale.timeseries.js","../node_modules/chart.js/src/index.ts","../node_modules/@kurkle/color/dist/color.esm.js","../node_modules/chart.js/src/helpers/helpers.core.ts","../node_modules/chart.js/src/helpers/helpers.math.ts","../node_modules/chart.js/src/helpers/helpers.collection.ts","../node_modules/chart.js/src/helpers/helpers.extras.ts","../node_modules/chart.js/src/helpers/helpers.easing.ts","../node_modules/chart.js/src/helpers/helpers.color.ts","../node_modules/chart.js/src/core/core.animations.defaults.js","../node_modules/chart.js/src/helpers/helpers.intl.ts","../node_modules/chart.js/src/core/core.ticks.js","../node_modules/chart.js/src/core/core.defaults.js","../node_modules/chart.js/src/core/core.layouts.defaults.js","../node_modules/chart.js/src/core/core.scale.defaults.js","../node_modules/chart.js/src/helpers/helpers.canvas.ts","../node_modules/chart.js/src/helpers/helpers.options.ts","../node_modules/chart.js/src/helpers/helpers.config.ts","../node_modules/chart.js/src/helpers/helpers.curve.ts","../node_modules/chart.js/src/helpers/helpers.dom.ts","../node_modules/chart.js/src/helpers/helpers.interpolation.ts","../node_modules/chart.js/src/helpers/helpers.rtl.ts","../node_modules/chart.js/src/helpers/helpers.segment.js","../node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"],"sourcesContent":["'use client';\nimport * as React from 'react';\nimport { PrimeReactContext } from 'primereact/api';\nimport { ComponentBase, useHandleStyle } from 'primereact/componentbase';\nimport { useMergeProps, useUnmountEffect } from 'primereact/hooks';\nimport { classNames } from 'primereact/utils';\n\nvar ChartBase = ComponentBase.extend({\n  defaultProps: {\n    __TYPE: 'Chart',\n    id: null,\n    type: null,\n    data: null,\n    options: null,\n    plugins: null,\n    width: null,\n    height: null,\n    style: null,\n    className: null,\n    children: undefined\n  },\n  css: {\n    classes: {\n      root: 'p-chart'\n    },\n    inlineStyles: {\n      root: function root(_ref) {\n        var props = _ref.props;\n        return Object.assign({\n          width: props.width,\n          height: props.height\n        }, props.style);\n      }\n    },\n    styles: \"\\n        @layer primereact {\\n            .p-chart {\\n                position: relative\\n            }\\n        }\\n        \"\n  }\n});\n\n// GitHub #3059 wrapper if loaded by script tag\nvar ChartJS = function () {\n  try {\n    return Chart;\n  } catch (_unused) {\n    return null;\n  }\n}();\nvar PrimeReactChart = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (inProps, ref) {\n  var mergeProps = useMergeProps();\n  var context = React.useContext(PrimeReactContext);\n  var props = ChartBase.getProps(inProps, context);\n  var _ChartBase$setMetaDat = ChartBase.setMetaData({\n      props: props\n    }),\n    ptm = _ChartBase$setMetaDat.ptm,\n    cx = _ChartBase$setMetaDat.cx,\n    sx = _ChartBase$setMetaDat.sx,\n    isUnstyled = _ChartBase$setMetaDat.isUnstyled;\n  useHandleStyle(ChartBase.css.styles, isUnstyled, {\n    name: 'chart'\n  });\n  var elementRef = React.useRef(null);\n  var chartRef = React.useRef(null);\n  var canvasRef = React.useRef(null);\n  var initChart = function initChart() {\n    destroyChart();\n    var configuration = {\n      type: props.type,\n      data: props.data,\n      options: props.options,\n      plugins: props.plugins\n    };\n    if (ChartJS) {\n      // GitHub #3059 loaded by script only\n      chartRef.current = new ChartJS(canvasRef.current, configuration);\n    } else {\n      import('chart.js/auto').then(function (module) {\n        destroyChart();\n\n        // In case that the Chart component has been unmounted during asynchronous loading of ChartJS,\n        // the canvasRef will not be available anymore, and no Chart should be created.\n        if (!canvasRef.current) {\n          return;\n        }\n        if (module) {\n          if (module[\"default\"]) {\n            // WebPack\n            chartRef.current = new module[\"default\"](canvasRef.current, configuration);\n          } else {\n            // ParcelJS\n            chartRef.current = new module(canvasRef.current, configuration);\n          }\n        }\n      });\n    }\n  };\n  var destroyChart = function destroyChart() {\n    if (chartRef.current) {\n      chartRef.current.destroy();\n      chartRef.current = null;\n    }\n  };\n  React.useImperativeHandle(ref, function () {\n    return {\n      props: props,\n      getCanvas: function getCanvas() {\n        return canvasRef.current;\n      },\n      getChart: function getChart() {\n        return chartRef.current;\n      },\n      getBase64Image: function getBase64Image() {\n        return chartRef.current.toBase64Image();\n      },\n      getElement: function getElement() {\n        return elementRef.current;\n      },\n      generateLegend: function generateLegend() {\n        return chartRef.current && chartRef.current.generateLegend();\n      },\n      refresh: function refresh() {\n        return chartRef.current && chartRef.current.update();\n      }\n    };\n  });\n  React.useEffect(function () {\n    initChart();\n  });\n  useUnmountEffect(function () {\n    destroyChart();\n  });\n  var title = props.options && props.options.plugins && props.options.plugins.title && props.options.plugins.title.text;\n  var ariaLabel = props.ariaLabel || title;\n  var rootProps = mergeProps({\n    id: props.id,\n    ref: elementRef,\n    style: sx('root'),\n    className: classNames(props.className, cx('root'))\n  }, ChartBase.getOtherProps(props), ptm('root'));\n  var canvasProps = mergeProps({\n    ref: canvasRef,\n    width: props.width,\n    height: props.height,\n    role: 'img',\n    'aria-label': ariaLabel\n  }, ptm('canvas'));\n  return /*#__PURE__*/React.createElement(\"div\", rootProps, /*#__PURE__*/React.createElement(\"canvas\", canvasProps));\n}), function (prevProps, nextProps) {\n  return prevProps.data === nextProps.data && prevProps.options === nextProps.options && prevProps.type === nextProps.type;\n});\nPrimeReactChart.displayName = 'Chart';\n\nexport { PrimeReactChart as Chart };\n","var _excluded = [\"color\", \"size\", \"title\", \"className\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar Calendar = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var color = _ref.color,\n      size = _ref.size,\n      title = _ref.title,\n      className = _ref.className,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 16 16\",\n    width: size,\n    height: size,\n    fill: color,\n    className: ['bi', 'bi-calendar', className].filter(Boolean).join(' ')\n  }, rest), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5M1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4z\"\n  }));\n});\nCalendar.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  title: PropTypes.string,\n  className: PropTypes.string\n};\nCalendar.defaultProps = {\n  color: 'currentColor',\n  size: '1em',\n  title: null,\n  className: ''\n};\nexport default Calendar;","var _excluded = [\"color\", \"size\", \"title\", \"className\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar ClipboardData = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var color = _ref.color,\n      size = _ref.size,\n      title = _ref.title,\n      className = _ref.className,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 16 16\",\n    width: size,\n    height: size,\n    fill: color,\n    className: ['bi', 'bi-clipboard-data', className].filter(Boolean).join(' ')\n  }, rest), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M4 11a1 1 0 1 1 2 0v1a1 1 0 1 1-2 0zm6-4a1 1 0 1 1 2 0v5a1 1 0 1 1-2 0zM7 9a1 1 0 0 1 2 0v3a1 1 0 1 1-2 0z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0z\"\n  }));\n});\nClipboardData.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  title: PropTypes.string,\n  className: PropTypes.string\n};\nClipboardData.defaultProps = {\n  color: 'currentColor',\n  size: '1em',\n  title: null,\n  className: ''\n};\nexport default ClipboardData;","var _excluded = [\"color\", \"size\", \"title\", \"className\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar Google = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var color = _ref.color,\n      size = _ref.size,\n      title = _ref.title,\n      className = _ref.className,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 16 16\",\n    width: size,\n    height: size,\n    fill: color,\n    className: ['bi', 'bi-google', className].filter(Boolean).join(' ')\n  }, rest), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M15.545 6.558a9.4 9.4 0 0 1 .139 1.626c0 2.434-.87 4.492-2.384 5.885h.002C11.978 15.292 10.158 16 8 16A8 8 0 1 1 8 0a7.7 7.7 0 0 1 5.352 2.082l-2.284 2.284A4.35 4.35 0 0 0 8 3.166c-2.087 0-3.86 1.408-4.492 3.304a4.8 4.8 0 0 0 0 3.063h.003c.635 1.893 2.405 3.301 4.492 3.301 1.078 0 2.004-.276 2.722-.764h-.003a3.7 3.7 0 0 0 1.599-2.431H8v-3.08z\"\n  }));\n});\nGoogle.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  title: PropTypes.string,\n  className: PropTypes.string\n};\nGoogle.defaultProps = {\n  color: 'currentColor',\n  size: '1em',\n  title: null,\n  className: ''\n};\nexport default Google;","var _excluded = [\"color\", \"size\", \"title\", \"className\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar PieChart = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var color = _ref.color,\n      size = _ref.size,\n      title = _ref.title,\n      className = _ref.className,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 16 16\",\n    width: size,\n    height: size,\n    fill: color,\n    className: ['bi', 'bi-pie-chart', className].filter(Boolean).join(' ')\n  }, rest), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M7.5 1.018a7 7 0 0 0-4.79 11.566L7.5 7.793zm1 0V7.5h6.482A7 7 0 0 0 8.5 1.018M14.982 8.5H8.207l-4.79 4.79A7 7 0 0 0 14.982 8.5M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8\"\n  }));\n});\nPieChart.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  title: PropTypes.string,\n  className: PropTypes.string\n};\nPieChart.defaultProps = {\n  color: 'currentColor',\n  size: '1em',\n  title: null,\n  className: ''\n};\nexport default PieChart;","var _excluded = [\"color\", \"size\", \"title\", \"className\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar Speedometer2 = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var color = _ref.color,\n      size = _ref.size,\n      title = _ref.title,\n      className = _ref.className,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 16 16\",\n    width: size,\n    height: size,\n    fill: color,\n    className: ['bi', 'bi-speedometer2', className].filter(Boolean).join(' ')\n  }, rest), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M8 4a.5.5 0 0 1 .5.5V6a.5.5 0 0 1-1 0V4.5A.5.5 0 0 1 8 4M3.732 5.732a.5.5 0 0 1 .707 0l.915.914a.5.5 0 1 1-.708.708l-.914-.915a.5.5 0 0 1 0-.707M2 10a.5.5 0 0 1 .5-.5h1.586a.5.5 0 0 1 0 1H2.5A.5.5 0 0 1 2 10m9.5 0a.5.5 0 0 1 .5-.5h1.5a.5.5 0 0 1 0 1H12a.5.5 0 0 1-.5-.5m.754-4.246a.39.39 0 0 0-.527-.02L7.547 9.31a.91.91 0 1 0 1.302 1.258l3.434-4.297a.39.39 0 0 0-.029-.518z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M0 10a8 8 0 1 1 15.547 2.661c-.442 1.253-1.845 1.602-2.932 1.25C11.309 13.488 9.475 13 8 13c-1.474 0-3.31.488-4.615.911-1.087.352-2.49.003-2.932-1.25A8 8 0 0 1 0 10m8-7a7 7 0 0 0-6.603 9.329c.203.575.923.876 1.68.63C4.397 12.533 6.358 12 8 12s3.604.532 4.923.96c.757.245 1.477-.056 1.68-.631A7 7 0 0 0 8 3\"\n  }));\n});\nSpeedometer2.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  title: PropTypes.string,\n  className: PropTypes.string\n};\nSpeedometer2.defaultProps = {\n  color: 'currentColor',\n  size: '1em',\n  title: null,\n  className: ''\n};\nexport default Speedometer2;","var _excluded = [\"color\", \"size\", \"title\", \"className\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar TextParagraph = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var color = _ref.color,\n      size = _ref.size,\n      title = _ref.title,\n      className = _ref.className,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 16 16\",\n    width: size,\n    height: size,\n    fill: color,\n    className: ['bi', 'bi-text-paragraph', className].filter(Boolean).join(' ')\n  }, rest), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M2 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5m0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5m0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5m4-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5\"\n  }));\n});\nTextParagraph.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  title: PropTypes.string,\n  className: PropTypes.string\n};\nTextParagraph.defaultProps = {\n  color: 'currentColor',\n  size: '1em',\n  title: null,\n  className: ''\n};\nexport default TextParagraph;","var _excluded = [\"color\", \"size\", \"title\", \"className\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar WindowDesktop = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var color = _ref.color,\n      size = _ref.size,\n      title = _ref.title,\n      className = _ref.className,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 16 16\",\n    width: size,\n    height: size,\n    fill: color,\n    className: ['bi', 'bi-window-desktop', className].filter(Boolean).join(' ')\n  }, rest), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M3.5 11a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h9a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M2.375 1A2.366 2.366 0 0 0 0 3.357v9.286A2.366 2.366 0 0 0 2.375 15h11.25A2.366 2.366 0 0 0 16 12.643V3.357A2.366 2.366 0 0 0 13.625 1zM1 3.357C1 2.612 1.611 2 2.375 2h11.25C14.389 2 15 2.612 15 3.357V4H1zM1 5h14v7.643c0 .745-.611 1.357-1.375 1.357H2.375A1.366 1.366 0 0 1 1 12.643z\"\n  }));\n});\nWindowDesktop.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  title: PropTypes.string,\n  className: PropTypes.string\n};\nWindowDesktop.defaultProps = {\n  color: 'currentColor',\n  size: '1em',\n  title: null,\n  className: ''\n};\nexport default WindowDesktop;","import {requestAnimFrame} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('./core.animation.js').default } Animation\n * @typedef { import('./core.controller.js').default } Chart\n */\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is export for typedoc\n */\nexport class Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  /**\n\t * @private\n\t */\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _update(date = Date.now()) {\n    let remaining = 0;\n\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            // if the animation has been updated and its duration prolonged,\n            // update to total duration of current animations run (for progress event)\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          // Remove the item by replacing it with last item and removing the last\n          // A lot faster than splice.\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    this._lastDate = date;\n\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} event - event name\n\t * @param {Function} cb - callback\n\t */\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  /**\n\t * Add animations\n\t * @param {Chart} chart\n\t * @param {Animation[]} items - animations\n\t */\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n\n  /**\n\t * Counts number of active animations for the chart\n\t * @param {Chart} chart\n\t */\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  /**\n\t * Start animating (all charts)\n\t * @param {Chart} chart\n\t */\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n\t * Stop all animations for the chart\n\t * @param {Chart} chart\n\t */\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  /**\n\t * Remove chart from Animator\n\t * @param {Chart} chart\n\t */\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Animator();\n","import effects from '../helpers/helpers.easing.js';\nimport {resolve} from '../helpers/helpers.options.js';\nimport {color as helpersColor} from '../helpers/helpers.color.js';\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @param {number} factor\n   */\n  color(from, to, factor) {\n    const c0 = helpersColor(from || transparent);\n    const c1 = c0.valid && helpersColor(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\n\nexport default class Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    if (this._active) {\n      // update current evaluated value, for smoother animations\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n\n    this._active = from !== to && (loop || (elapsed < duration));\n\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\n    this._target[prop] = this._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n","import animator from './core.animator.js';\nimport Animation from './core.animation.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isObject} from '../helpers/helpers.core.js';\n\nexport default class Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  /**\n\t * Utility to handle animation of `options`.\n\t * @private\n\t */\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      // Going to shared options:\n      // After all animations are done, assign the shared options object to the element\n      // So any new updates to the shared options are observed\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n        // rejected, noop\n      });\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @private\n\t */\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          // There is an existing active animation, let's update that\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        // not animated, set directly to new value\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n\n\n  /**\n\t * Update `target` properties to new values, using configured animations\n\t * @param {object} target - object to update\n\t * @param {object} values - new target properties\n\t * @returns {boolean|undefined} - `true` if animations were started\n\t **/\n  update(target, values) {\n    if (this._properties.size === 0) {\n      // Nothing is animated, just apply the new values.\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  // @ts-ignore\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    // Going from shared options to distinct one:\n    // Create new options object containing the old shared values and start updating that.\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n","import Animations from './core.animations.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\nimport {createContext, sign} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('./core.scale.js').default } Scale\n */\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  let found = false;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      found = true;\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n\n  if (!found && !options.all) {\n    return 0;\n  }\n\n  return value;\n}\n\nfunction convertObjectDataToArray(data, meta) {\n  const {iScale, vScale} = meta;\n  const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n  const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      [iAxisKey]: key,\n      [vAxisKey]: data[key]\n    };\n  }\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\n\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  // Not using meta.index here, because it might be already updated if the dataset changed location\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\n\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\nexport default class DatasetController {\n\n  /**\n   * @type {any}\n   */\n  static defaults = {};\n\n  /**\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\n   */\n  static datasetElementType = null;\n\n  /**\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\n   */\n  static dataElementType = null;\n\n  /**\n\t * @param {Chart} chart\n\t * @param {number} datasetIndex\n\t */\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    /** @type {boolean | object} */\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n\n    this.initialize();\n  }\n\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  /**\n\t * @param {string} scaleID\n\t * @return {Scale}\n\t */\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  /**\n\t * @private\n\t */\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  /**\n\t * @private\n\t */\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n\n    // In order to correctly handle data addition/deletion animation (and thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal metadata accordingly.\n\n    if (isObject(data)) {\n      const meta = this._cachedMeta;\n      this._data = convertObjectDataToArray(data, meta);\n    } else if (_data !== data) {\n      if (_data) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(_data, this);\n        // Discard old parsed data and stacks\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n\n  addElements() {\n    const meta = this._cachedMeta;\n\n    this._dataCheck();\n\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n\n    this._dataCheck();\n\n    // make sure cached _stacked status is current\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    // detect change in stack option\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      // remove values from old stack\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    // Re-sync meta data in case the user replaced the data array or if we missed\n    // any updates and so make sure that we handle number of datapoints changing.\n    this._resyncElements(resetNewElements);\n\n    // if stack changed, update stack values for the whole dataset\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n      meta._stacked = isStacked(meta.vScale, meta);\n    }\n  }\n\n  /**\n\t * Merges user-supplied and default dataset-level options\n\t * @private\n\t */\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n\n  /**\n\t * @param {number} start\n\t * @param {number} count\n\t */\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [1,3,4]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {xScale0: 0, yScale0: 1}\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {x: 0, y: 1}\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id. _custom is optional\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        // if the data is sorted, we don't need to check further from this end of array\n        break;\n      }\n    }\n    if (sorted) {\n      // in the sorted case, find first non-skipped value from other end of array\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return false;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {} // eslint-disable-line no-unused-vars\n\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  /**\n\t * Returns a set of predefined style properties that should be used to represent the dataset\n\t * or the data if the index is specified\n\t * @param {number} index - data index\n\t * @param {boolean} [active] - true if hover\n\t * @return {object} style object\n\t */\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  /**\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    // context is provided as a function, and is called only if needed,\n    // so we don't create a context for each element if not needed.\n    const context = () => this.getContext(index, active, mode);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      // `$shared` indicates this set of options can be shared between multiple elements.\n      // Sharing is used to reduce number of properties to change during animation.\n      values.$shared = sharing;\n\n      // We cache options by `mode`, which can be 'active' for example. This enables us\n      // to have the 'active' element options and 'default' options to switch between\n      // when interacting.\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n\n  /**\n\t * Utility for getting the options object shared between elements\n\t * @protected\n\t */\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  /**\n\t * Utility for determining if `options` should be included in the updated properties\n\t * @protected\n\t */\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  /**\n   * @todo v4, rename to getSharedOptions and remove excess functions\n   */\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n\n  /**\n\t * Utility for updating an element with new properties, using animations when appropriate.\n\t * @protected\n\t */\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  /**\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\n\t * @protected\n\t */\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      // When going from active to inactive, we need to update to the shared options.\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  /**\n\t * @private\n\t */\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n\n    // Apply changes detected through array listeners\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      // TODO: It is not optimal to always parse the old data\n      // This is done because we are not detecting direct assignments:\n      // chart.data.datasets[0].data[5] = 10;\n      // chart.data.datasets[0].data[5].y = 10;\n      this.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @private\n\t */\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n\n  /**\n\t * @private\n   */\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {\n  _arrayUnique, isArray, isNullOrUndef,\n  valueOrDefault, resolveObjectKey, sign, defined\n} from '../helpers/index.js';\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      // Ignore truncated pixels\n      return;\n    }\n    if (defined(prev)) {\n      // curr - prev === 0 is ignored\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale size.\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\n\nexport default class BarController extends DatasetController {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'bar',\n\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'base', 'width', 'height']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: 'linear',\n        beginAtZero: true,\n      }\n    }\n  };\n\n\n  /**\n\t * Overriding primitive data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding array data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding object data parsing since we support mixed primitive/array\n\t * value-scale data for float bars\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      // float bar: only one end of the bar is considered by `super`\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    this.enableOptionSharing = true;\n\n    super.initialize();\n\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  /**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @param {number} [dataIndex] - The data index of the ruler\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n    const iScaleValue = currentParsed && currentParsed[iScale.axis];\n\n    const skipNull = (meta) => {\n      const parsed = meta._parsed.find(item => item[iScale.axis] === iScaleValue);\n      const val = parsed && parsed[meta.vScale.axis];\n\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n\n      // stacked   | meta.stack\n      //           | found | not found | undefined\n      // false     |   x   |     x     |     x\n      // true      |       |     x     |\n      // undefined |       |     x     |     x\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\n    // stack where possible invisible bars will be located.\n    // https://github.com/chartjs/Chart.js/issues/6368\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  /**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  /**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n   * @param {number} [dataIndex]\n\t * @returns {number} The stack index\n\t * @private\n\t */\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1; // indexOf returns -1 if element is not present\n\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      // bar thickness ratio used for non-grouped bars\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  /**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      // bars crossing origin are not stacked\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      // When not visible, no height\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n\n      if (_stacked && !floating) {\n        // visual data coordinates after applying minBarLength\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      // For non-grouped bar charts, exact pixel values are used\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {valueOrDefault} from '../helpers/helpers.core.js';\n\nexport default class BubbleController extends DatasetController {\n\n  static id = 'bubble';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'borderWidth', 'radius']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const points = this._cachedMeta.data;\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    // In case values were cached (and thus frozen), we need to clone the values\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n\n    // Custom radius resolution\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\n    return values;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\n\nexport default class DoughnutController extends DatasetController {\n\n  static id = 'doughnut';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'arc',\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n      },\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutout: '50%',\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%',\n\n    // Spacing between arcs\n    spacing: 0,\n\n    indexAxis: 'r',\n  };\n\n  static descriptors = {\n    _scriptable: (name) => name !== 'spacing',\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    // Need to override these to give a nice default\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  /**\n\t * Override data parsing, since we are not using scales\n\t */\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  /**\n\t * @private\n\t */\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  /**\n\t * Get the maximal rotation & circumference extents\n\t * across all visible datasets.\n\t */\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n\n    // Compute the maximal rotation & circumference limits.\n    // If we only consider our dataset, this can cause problems when two datasets\n    // are both less than a circle with different rotations (starting angles)\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n\n    meta.total = this.calculateTotal();\n\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @private\n   */\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      // Find the outmost visible dataset\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n\n  /**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  /**\n\t * Returns the sum of all visible data set weights.\n\t * @private\n\t */\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class LineController extends DatasetController {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n\n    showLine: true,\n    spanGaps: false,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n      },\n      _value_: {\n        type: 'linear',\n      },\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    // Update Line\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class PolarAreaController extends DatasetController {\n\n  static id = 'polarArea';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    dataElementType: 'arc',\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n      },\n    },\n    indexAxis: 'r',\n    startAngle: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @protected\n   */\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n\n    return range;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n\n    const defaultAngle = 360 / this.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\n","import DoughnutController from './controller.doughnut.js';\n\n// Pie charts are Doughnut chart with different defaults\nexport default class PieController extends DoughnutController {\n\n  static id = 'pie';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    // The percentage of the chart that we cut out of the middle.\n    cutout: 0,\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%'\n  };\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class RadarController extends DatasetController {\n\n  static id = 'radar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n    indexAxis: 'r',\n    showLine: true,\n    elements: {\n      line: {\n        fill: 'start'\n      }\n    },\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n\n    // Update Line\n    line.points = points;\n    // In resize mode only point locations change, so no need to set the points or options.\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n\n      this.updateElement(line, undefined, properties, mode);\n    }\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class ScatterController extends DatasetController {\n\n  static id = 'scatter';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n    showLine: false,\n    fill: false\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n\n    interaction: {\n      mode: 'point'\n    },\n\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + ')'\n    };\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    if (this.options.showLine) {\n\n      // https://github.com/chartjs/Chart.js/issues/11333\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {dataset: line, _dataset} = meta;\n\n      // Update Line\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      // https://github.com/chartjs/Chart.js/issues/11333\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  addElements() {\n    const {showLine} = this.options;\n\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement('line');\n    }\n\n    super.addElements();\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\n","/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartOptions} from '../types/index.js';\n\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\n\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\n  readonly options: T;\n  /**\n   * Will called with chart options after adapter creation.\n   */\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\n  /**\n   * Returns a map of time formats for the supported formatting units defined\n   * in Unit as well as 'datetime' representing a detailed date/time string.\n   */\n  formats(this: DateAdapter<T>): Record<string, string>;\n  /**\n   * Parses the given `value` and return the associated timestamp.\n   * @param value - the value to parse (usually comes from the data)\n   * @param [format] - the expected data format\n   */\n  parse(this: DateAdapter<T>, value: unknown, format?: TimeUnit): number | null;\n  /**\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\n   * @param timestamp - the timestamp to format\n   * @param format - the date/time token\n   */\n  format(this: DateAdapter<T>, timestamp: number, format: TimeUnit): string;\n  /**\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param amount - the amount to add\n   * @param unit - the unit as string\n   */\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\n  /**\n   * Returns the number of `unit` between the given timestamps.\n   * @param a - the input timestamp (reference)\n   * @param b - the timestamp to subtract\n   * @param unit - the unit as string\n   */\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\n  /**\n   * Returns start of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   * @param [weekday] - the ISO day of the week with 1 being Monday\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n   */\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number): number;\n  /**\n   * Returns end of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   */\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek'): number;\n}\n\nfunction abstract<T = void>(): T {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\nclass DateAdapterBase implements DateAdapter {\n\n  /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */\n  static override<T extends AnyObject = AnyObject>(\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\n  ) {\n    Object.assign(DateAdapterBase.prototype, members);\n  }\n\n  readonly options: AnyObject;\n\n  constructor(options: AnyObject) {\n    this.options = options || {};\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {}\n\n  formats(): Record<string, string> {\n    return abstract();\n  }\n\n  parse(): number | null {\n    return abstract();\n  }\n\n  format(): string {\n    return abstract();\n  }\n\n  add(): number {\n    return abstract();\n  }\n\n  diff(): number {\n    return abstract();\n  }\n\n  startOf(): number {\n    return abstract();\n  }\n\n  endOf(): number {\n    return abstract();\n  }\n}\n\nexport default {\n  _date: DateAdapterBase\n};\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\nimport {_isPointInArea} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\n * @typedef { import('../types/index.js').Point } Point\n */\n\n/**\n * Helper function to do binary search when possible\n * @param {object} metaset - the dataset meta\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {number} value - the value to find\n * @param {boolean} [intersect] - should the element intersect\n * @returns {{lo:number, hi:number}} indices to search data array between\n */\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      // _sharedOptions indicates that each element has equal options -> equal proportions\n      // So we can do a ranged binary search based on the range of first element and\n      // be confident to get the full range of indices that can intersect with the value.\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  // Default to all elements, when binary search can not be used.\n  return {lo: 0, hi: data.length - 1};\n}\n\n/**\n * Helper function to select candidate elements for interaction\n * @param {Chart} chart - the chart\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {function} handler - the callback to execute for each visible item\n * @param {boolean} [intersect] - consider intersecting items\n */\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy|r\n */\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {Chart} chart - the chart\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a radial chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a cartesian chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in the chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n\n/**\n * Helper function to get the items matching along the given X or Y axis\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis to match\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n\n  // If we want to trigger on an intersect and we don't have any items\n  // that intersect the position, return nothing\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nexport default {\n  // Part of the public API to facilitate developers creating their own modes\n  evaluateInteractionItems,\n\n  // Helper function for different modes\n  modes: {\n    /**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      // Default axis for index mode is 'x' to match old behaviour\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        // don't count items that are skipped (null data)\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n\n      return elements;\n    },\n\n    /**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n\n      return items;\n    },\n\n    /**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n\n    /**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\nimport {toPadding} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n */\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\n\n/**\n * store dimensions used instead of available chartArea in fitBoxes\n **/\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  // dynamically placed boxes size is not considered\n  if (!isObject(pos)) {\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n\n  // return booleans on the changes per direction\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\n    // Dimensions changed and there were non full width boxes before this\n    // -> we have to refit those\n    refit |= same && refitBoxes.length;\n\n    // Chart area changed in the opposite direction\n    changed = changed || other;\n\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\n/**\n * @interface LayoutItem\n * @typedef {object} LayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} draw - Draws the element\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nexport default {\n\n  /**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {LayoutItem} item - the item to add to be laid out\n\t */\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    // initialize item with default values\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    // @ts-ignore\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  /**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\n\t */\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {LayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  /**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n   * @param {number} minPadding - minimum padding required for each side of chart area\n\t */\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n\n    // Before any changes are made, notify boxes that an update is about to being\n    // This is used to clear any cached data (e.g. scale limits)\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n\n    // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\n    // Then fit vertical boxes\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    // Then fit horizontal boxes\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      // if the area changed, re-fit vertical boxes\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n\n    // Finally place the boxes to correct coordinates\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\n    // Move to opposite side of chart\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n\n    // Finally update boxes in chartArea (radial scale for example)\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n","\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\n/**\n * Abstract class that allows abstracting platform dependencies away from the chart.\n */\nexport default class BasePlatform {\n  /**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n\t * @param {number} [aspectRatio] - The chart options\n\t */\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n  releaseContext(context) { // eslint-disable-line no-unused-vars\n    return false;\n  }\n\n  /**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\n\t */\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n\t */\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  /**\n\t * Returns the maximum size in pixels of given canvas element.\n\t * @param {HTMLCanvasElement} element\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\n\t */\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n  /**\n   * Updates config with platform specific requirements\n   * @param {import('../core/core.config.js').default} config\n   */\n  updateConfig(config) { // eslint-disable-line no-unused-vars\n    // no-op\n  }\n}\n","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nimport BasePlatform from './platform.base.js';\n\n/**\n * Platform class for charts without access to the DOM or to many element properties\n * This platform is used by default for any chart passed an OffscreenCanvas.\n * @extends BasePlatform\n */\nexport default class BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\nimport BasePlatform from './platform.base.js';\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\nimport {throttled} from '../helpers/helpers.extras.js';\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nconst EXPANDO_KEY = '$chartjs';\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n * @param {HTMLCanvasElement} canvas\n * @param {number} [aspectRatio]\n */\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n  // returns null or '' if no explicit value has been set to the canvas attribute.\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n\n  // Chart.js modifies some canvas values that we want to restore on destroy\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n\n  // Force canvas to display as block to avoid extra space caused by inline\n  // elements, which would interfere with the responsive resize process.\n  // https://github.com/chartjs/Chart.js/issues/2538\n  style.display = style.display || 'block';\n  // Include possible borders in the size\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      // If no explicit render height and style height, let's apply the aspect ratio,\n      // which one can be specified by the user but also by charts as default option\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n  if (node) {\n    node.addEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction removeListener(chart, type, listener) {\n  if (chart && chart.canvas) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\n\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      // If the container size shrank during chart resize, let's assume\n      // scrollbar appeared. So we resize again with the scrollbar visible -\n      // effectively making chart smaller and the scrollbar hidden again.\n      // Because we are inside `throttled`, and currently `ticking`, scroll\n      // events are ignored during this whole 2 resize process.\n      // If we assumed wrong and something else happened, we are resizing\n      // twice in a frame (potential performance issue)\n      listener();\n    }\n  }, window);\n\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    // When its container's display is set to 'none' the callback will be called with a\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\n    // resizing in such case.\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    // This case can occur if the chart is destroyed while waiting\n    // for the throttled function to occur. We prevent crashes by checking\n    // for a destroyed chart\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n\n  addListener(canvas, type, proxy);\n\n  return proxy;\n}\n\n/**\n * Platform class for charts that can access the DOM and global window/document properties\n * @extends BasePlatform\n */\nexport default class DomPlatform extends BasePlatform {\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [aspectRatio]\n\t * @return {CanvasRenderingContext2D|null}\n\t */\n  acquireContext(canvas, aspectRatio) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\n    // inside an iframe or when running in a protected environment. We could guess the\n    // types from their toString() value but let's keep things flexible and assume it's\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\n    // https://github.com/chartjs/Chart.js/issues/3887\n    // https://github.com/chartjs/Chart.js/issues/4102\n    // https://github.com/chartjs/Chart.js/issues/4152\n    if (context && context.canvas === canvas) {\n      // Load platform resources on first chart creation, to make it possible to\n      // import the library before setting platform options.\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  /**\n\t * @param {CanvasRenderingContext2D} context\n\t */\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n\n    // The canvas render size might have been changed (and thus the state stack discarded),\n    // we can't use save() and restore() to restore the initial state. So make sure that at\n    // least the canvas context is reset to the default state by setting the canvas width.\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  /**\n\t *\n\t * @param {Chart} chart\n\t * @param {string} type\n\t * @param {function} listener\n\t */\n  addEventListener(chart, type, listener) {\n    // Can have only one listener per type, so make sure previous is removed\n    this.removeEventListener(chart, type);\n\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} type\n\t */\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t */\n  isAttached(canvas) {\n    const container = canvas && _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n","import {_isDomSupported} from '../helpers/index.js';\nimport BasePlatform from './platform.base.js';\nimport BasicPlatform from './platform.basic.js';\nimport DomPlatform from './platform.dom.js';\n\nexport function _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nexport {BasePlatform, BasicPlatform, DomPlatform};\n","import type {AnyObject} from '../types/basic.js';\nimport type {Point} from '../types/geometric.js';\nimport type {Animation} from '../types/animation.js';\nimport {isNumber} from '../helpers/helpers.math.js';\n\nexport default class Element<T = AnyObject, O = AnyObject> {\n\n  static defaults = {};\n  static defaultRoutes = undefined;\n\n  x: number;\n  y: number;\n  active = false;\n  options: O;\n  $animations: Record<keyof T, Animation>;\n\n  tooltipPosition(useFinalPosition: boolean): Point {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y} as Point;\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  /**\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\n   * @param props - properties to get\n   * @param [final] - get the final value (animation target)\n   */\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      // let's not create an object, if not needed\n      return this as Record<string, unknown>;\n    }\n    const ret: Record<string, unknown> = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\n    });\n    return ret;\n  }\n}\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\nimport {_factorize} from '../helpers/helpers.math.js';\n\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\n * @param {import('./core.scale.js').default} scale\n * @param {Tick[]} ticks\n * @return {Tick[]}\n * @private\n */\nexport function autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  // If there are too many major ticks to display them all\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\n/**\n * @param {number[]} majorIndices\n * @param {Tick[]} ticks\n * @param {number} ticksLimit\n */\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  // If the major ticks are evenly spaced apart, place the minor ticks\n  // so that they divide the major ticks into even chunks\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\n\n/**\n * @param {Tick[]} ticks\n */\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number[]} majorIndices\n * @param {number} spacing\n */\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number} spacing\n * @param {number} [majorStart]\n * @param {number} [majorEnd]\n */\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\n\n/**\n * @param {number[]} arr\n */\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n","import Element from './core.element.js';\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\nimport {autoSkip} from './core.scale.autoskip.js';\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\n\n/**\n * @typedef { import('../types/index.js').Chart } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a new array containing numItems from arr\n * @param {any[]} arr\n * @param {number} numItems\n */\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @param {boolean} offsetGridLines\n */\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n\n    // Return undefined if the pixel is out of the range\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\n\n/**\n * @param {object} caches\n * @param {number} length\n */\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\n/**\n * @param {object} options\n */\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\n/**\n * @param {object} options\n */\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n\n  return (lines * font.lineHeight) + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  /** @type {CanvasTextAlign} */\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\n\nexport default class Scale extends Element {\n\n  // eslint-disable-next-line max-statements\n  constructor(cfg) {\n    super();\n\n    /** @type {string} */\n    this.id = cfg.id;\n    /** @type {string} */\n    this.type = cfg.type;\n    /** @type {any} */\n    this.options = undefined;\n    /** @type {CanvasRenderingContext2D} */\n    this.ctx = cfg.ctx;\n    /** @type {Chart} */\n    this.chart = cfg.chart;\n\n    // implements box\n    /** @type {number} */\n    this.top = undefined;\n    /** @type {number} */\n    this.bottom = undefined;\n    /** @type {number} */\n    this.left = undefined;\n    /** @type {number} */\n    this.right = undefined;\n    /** @type {number} */\n    this.width = undefined;\n    /** @type {number} */\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /** @type {number} */\n    this.maxWidth = undefined;\n    /** @type {number} */\n    this.maxHeight = undefined;\n    /** @type {number} */\n    this.paddingTop = undefined;\n    /** @type {number} */\n    this.paddingBottom = undefined;\n    /** @type {number} */\n    this.paddingLeft = undefined;\n    /** @type {number} */\n    this.paddingRight = undefined;\n\n    // scale-specific properties\n    /** @type {string=} */\n    this.axis = undefined;\n    /** @type {number=} */\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    /** @type {Tick[]} */\n    this.ticks = [];\n    /** @type {object[]|null} */\n    this._gridLineItems = null;\n    /** @type {object[]|null} */\n    this._labelItems = null;\n    /** @type {object|null} */\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    /** @type {number} */\n    this._startPixel = undefined;\n    /** @type {number} */\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @param {any} options\n\t * @since 3.0\n\t */\n  init(options) {\n    this.options = options.setContext(this.getContext());\n\n    this.axis = options.axis;\n\n    // parse min/max value, so we can properly determine min/max for other scales\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n\n  /**\n\t * Parse a supported input value to internal representation.\n\t * @param {*} raw\n\t * @param {number} [index]\n\t * @since 3.0\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    return raw;\n  }\n\n  /**\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isFinite(_userMin),\n      maxDefined: isFinite(_userMax)\n    };\n  }\n\n  /**\n\t * @param {boolean} canStack\n\t * @return {{min: number, max: number}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  /**\n\t * Get the padding needed for the scale\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\n\t * @private\n\t */\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n\n  /**\n\t * Returns the scale tick objects\n\t * @return {Tick[]}\n\t * @since 2.7\n\t */\n  getTicks() {\n    return this.ticks;\n  }\n\n  /**\n\t * @return {string[]}\n\t */\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  /**\n   * @return {import('../types.js').LabelItem[]}\n   */\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n\n  // When a new layout is created, reset the data limits cache\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n\n  beforeUpdate() {\n    call(this.options.beforeUpdate, [this]);\n  }\n\n  /**\n\t * @param {number} maxWidth - the max width in pixels\n\t * @param {number} maxHeight - the max height in pixels\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\n\t *   This space comes from two sources:\n\t *     - padding - space that's required to show the labels at the edges of the scale\n\t *     - thickness of scales or legends in another orientation\n\t */\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n    this.beforeUpdate();\n\n    // Absorb the master measurements\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n\n    // Dimensions\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n\n    // Data min/max\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n\n    this.beforeBuildTicks();\n\n    this.ticks = this.buildTicks() || [];\n\n    // Allow modification of ticks in callback.\n    this.afterBuildTicks();\n\n    // Compute tick rotation and fit using a sampled subset of labels\n    // We generally don't need to compute the size of every single label for determining scale size\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\n    // configure is called twice, once here, once from core.controller.updateLayout.\n    // Here we haven't been positioned yet, but dimensions are correct.\n    // Variables set in configure are needed for calculateLabelRotation, and\n    // it's ok that coordinates are not correct there, only dimensions matter.\n    this.configure();\n\n    // Tick Rotation\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\n    this.afterCalculateLabelRotation();\n\n    // Auto-skip\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n\n    if (samplingEnabled) {\n      // Generate labels using all non-skipped ticks\n      this._convertTicksToLabels(this.ticks);\n    }\n\n    this.beforeFit();\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\n    this.afterFit();\n\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n    this.afterUpdate();\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      // by default vertical scales are from bottom to top, so pixels are reversed\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    call(this.options.afterUpdate, [this]);\n  }\n\n  //\n\n  beforeSetDimensions() {\n    call(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    if (this.isHorizontal()) {\n      // Reset position before calculating rotation\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n\n      // Reset position before calculating rotation\n      this.top = 0;\n      this.bottom = this.height;\n    }\n\n    // Reset padding\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    call(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    call(this.options[name], [this]);\n  }\n\n  // Data limits\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  //\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  /**\n\t * @return {object[]} the ticks\n\t */\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    call(this.options.beforeTickToLabelConversion, [this]);\n  }\n  /**\n\t * Convert ticks to label strings\n\t * @param {Tick[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    call(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  //\n\n  beforeCalculateLabelRotation() {\n    call(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    // Estimate the width of each grid based on the canvas width, the maximum\n    // label width and the number of tick intervals\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    // Allow 3 pixels x2 padding either side for label readability\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    call(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n\n  //\n\n  beforeFit() {\n    call(this.options.beforeFit, [this]);\n  }\n  fit() {\n    // Reset\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight; // fill all the height\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      // Don't bother fitting the ticks if we are not showing the labels\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    this._handleMargins();\n\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n      // which means that the right padding is dominated by the font height\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      // Adjust padding taking into account changes in offsets\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  /**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    call(this.options.afterFit, [this]);\n  }\n\n  // Shared Methods\n  /**\n\t * @return {boolean}\n\t */\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  /**\n\t * @return {boolean}\n\t */\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  /**\n\t * @param {Tick[]} ticks\n\t * @private\n\t */\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n\n    this.generateTickLabels(ticks);\n\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    this.afterTickToLabelConversion();\n  }\n\n  /**\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n\n    return labelSizes;\n  }\n\n  /**\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\n\t * labels where offset indicates the anchor point offset from the top in pixels.\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      // Undefined labels and arrays should not be measured\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = /** @type {string} */ (label[j]);\n          // Undefined labels and arrays should not be measured\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n\n  /**\n\t * Used to get the label to display in the tooltip for the given value\n\t * @param {*} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value;\n  }\n\n  /**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {*} value\n\t * @param {number} [index]\n\t * @return {number}\n\t */\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\n    return NaN;\n  }\n\n  /**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} pixel\n\t * @return {*}\n\t */\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} index\n\t * @return {number}\n\t */\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  /**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} decimal\n\t * @return {number}\n\t */\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  /**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @return {number}\n\t */\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  /**\n\t * @return {number}\n\t */\n  getBaseValue() {\n    const {min, max} = this;\n\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index) {\n    const ticks = this.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n\n  /**\n\t * @return {number}\n\t * @private\n\t */\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n\n    // Calculate space needed by label in axis direction.\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\n    // Calculate space needed for 1 tick in axis direction.\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  /**\n\t * @return {boolean}\n\t * @private\n\t */\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position, border} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\n      lineValue = getPixelForGridLine(this, i, offset);\n\n      // Skip if the pixel is out of the range\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n\n    return items;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += (lineHeight / 2) * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        default:\n          break;\n        }\n\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        case 'inner':\n          if (i === ilen - 1) {\n            left -= width;\n          } else if (i > 0) {\n            left -= width / 2;\n          }\n          break;\n        default:\n          break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n\n          color: optsAtIndex.backdropColor,\n        };\n      }\n\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop,\n        }\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {textAlign, x};\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = this.chart;\n    const position = this.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n\n  /**\n   * @protected\n   */\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {\n    const {chart, ctx, options: {border, grid}} = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = this.ctx;\n\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n\n  /**\n\t * @return {object[]}\n\t * @private\n\t */\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      // backward compatibility: draw has been overridden by custom scale\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n\n  /**\n\t * Returns visible dataset metas that are attached to this scale\n\t * @param {string} [type] - if specified, also filter by dataset type\n\t * @return {object[]}\n\t */\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n\n  /**\n\t * @param {number} index\n\t * @return {object}\n\t * @protected\n \t */\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  /**\n   * @protected\n   */\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n","import {merge} from '../helpers/index.js';\nimport defaults, {overrides} from './core.defaults.js';\n\n/**\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\n */\n\nexport default class TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t * @returns {string} The scope where items defaults were registered to.\n\t */\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      // Make sure the parent is registered and note the scope where its defaults are.\n      parentScope = this.register(proto);\n    }\n\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      // already registered\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object?}\n\t */\n  get(id) {\n    return this.items[id];\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t */\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  // Inherit the parent's defaults and keep existing defaults\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n","import DatasetController from './core.datasetController.js';\nimport Element from './core.element.js';\nimport Scale from './core.scale.js';\nimport TypedRegistry from './core.typedRegistry.js';\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    // Order is important, Scale has Element in prototype chain,\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof DatasetController}\n\t */\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Element}\n\t */\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object}\n\t */\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Scale}\n\t */\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  /**\n\t * @private\n\t */\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        // Handle loopable args\n        // Use case:\n        //  import * as plugins from './plugins.js';\n        //  Chart.register(plugins);\n        each(arg, item => {\n          // If there are mixed types in the loopable, make sure those are\n          // registered in correct registry\n          // Use case: (treemap exporting controller, elements etc)\n          //  import * as treemap from 'chartjs-chart-treemap.js';\n          //  Chart.register(treemap);\n\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\n    registry[method](component);\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\n  }\n\n  /**\n\t * @private\n\t */\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    // plugins is the fallback registry\n    return this.plugins;\n  }\n\n  /**\n\t * @private\n\t */\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Registry();\n","import registry from './core.registry.js';\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\n */\n\n/**\n * @callback filterCallback\n * @param {{plugin: object, options: object}} value\n * @param {number} [index]\n * @param {array} [array]\n * @param {object} [thisArg]\n * @return {boolean}\n */\n\n\nexport default class PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  /**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    // When plugins are registered, there is the possibility of a double\n    // invalidate situation. In this case, we only want to invalidate once.\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\n    // plugins are restarted without being correctly stopped.\n    // See https://github.com/chartjs/Chart.js/issues/8147\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    // options === false => all plugins are disabled\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\n\n/**\n * @param {import('./core.config.js').default} config\n */\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n\n  return {plugins, localIds};\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\n\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    // make sure plugin defaults are in scopes for local (not registered) plugins\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    // These are just defaults that plugins can override\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n","import defaults, {overrides, descriptors} from './core.defaults.js';\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\n\nexport function getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction idMatchesAxis(id) {\n  if (id === 'x' || id === 'y' || id === 'r') {\n    return id;\n  }\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nexport function determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis\n      || axisFromPosition(opts.position)\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\n\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + 'AxisID'] === id) {\n    return {axis};\n  }\n}\n\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n    }\n  }\n  return {};\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales = Object.create(null);\n\n  // First figure out first scale id's per axis.\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n\n  // Then merge dataset defaults to scale configs\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n\n  // apply scale defaults, if not overridden by dataset defaults\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n\n  initOptions(config);\n\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nexport default class Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @return {string[][]}\n   */\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset animation options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @param {string} transition\n   * @return {string[][]}\n   */\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        // The following are used for looking up the `animations` and `animation` keys\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving element options that belong\n   * to an dataset. These keys do not include the dataset itself, because it\n   * is not under options.\n   * @param {string} datasetType\n   * @param {string} elementType\n   * @return {string[][]}\n   */\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving plugin options.\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\n   * @return {string[][]}\n   */\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n\n  /**\n   * @private\n   */\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n\n  /**\n   * Resolves the objects from options and defaults for option value resolution.\n   * @param {object} mainScope - The main scope object for options\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\n   */\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n\n  /**\n   * Returns the option scopes for resolving chart options\n   * @return {object[]}\n   */\n  chartOptionScopes() {\n    const {options, type} = this;\n\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {string[]} names\n   * @param {function|object} context\n   * @param {string[]} [prefixes]\n   * @return {object}\n   */\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {object} [context]\n   * @param {string[]} [prefixes]\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\n   */\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\n\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));\n\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n","import animator from './core.animator.js';\nimport defaults, {overrides} from './core.defaults.js';\nimport Interaction from './core.interaction.js';\nimport layouts from './core.layouts.js';\nimport {_detectPlatform} from '../platform/index.js';\nimport PluginService from './core.plugins.js';\nimport registry from './core.registry.js';\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\nimport {retinaScale, _isDomSupported} from '../helpers/helpers.dom.js';\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea} from '../helpers/index.js';\n// @ts-ignore\nimport {version} from '../../package.json';\nimport {debounce} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').Point } Point\n */\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\n\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n\n  chart.notifyPlugins('afterRender');\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\n/**\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\n */\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    // Support for array based queries (such as jQuery)\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    // Support for any object associated to a canvas (including a context2d)\n    item = item.canvas;\n  }\n  return item;\n}\n\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\n\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\n\n/**\n * @param {ChartEvent} e\n * @param {ChartEvent|null} lastEvent\n * @param {boolean} inChartArea\n * @param {boolean} isClick\n * @returns {ChartEvent|null}\n */\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\n\nfunction getSizeForArea(scale, chartArea, field) {\n  return scale.options.clip ? scale[field] : chartArea[field];\n}\n\nfunction getDatasetArea(meta, chartArea) {\n  const {xScale, yScale} = meta;\n  if (xScale && yScale) {\n    return {\n      left: getSizeForArea(xScale, chartArea, 'left'),\n      right: getSizeForArea(xScale, chartArea, 'right'),\n      top: getSizeForArea(yScale, chartArea, 'top'),\n      bottom: getSizeForArea(yScale, chartArea, 'bottom')\n    };\n  }\n  return chartArea;\n}\n\nclass Chart {\n\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    // Store the previously used aspect ratio to determine if a resize\n    // is needed during updates. Do this after _options is set since\n    // aspectRatio uses a getter\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n\n    // Add the chart instance to the global namespace\n    instances[this.id] = this;\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      // If aspectRatio is defined in options, use that.\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\n      return _aspectRatio;\n    }\n\n    // Calculate\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  get registry() {\n    return registry;\n  }\n\n  /**\n\t * @private\n\t */\n  _initialize() {\n    // Before init plugin notification\n    this.notifyPlugins('beforeInit');\n\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n\n    this.bindEvents();\n\n    // After init plugin notification\n    this.notifyPlugins('afterInit');\n\n    return this;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  /**\n\t * Resize the chart to its container or to explicit dimensions.\n\t * @param {number} [width]\n\t * @param {number} [height]\n\t */\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n\n    this.notifyPlugins('resize', {size: newSize});\n\n    callCallback(options.onResize, [this, newSize], this);\n\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        // The resize update is delayed, only draw without updating.\n        this.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  /**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    // clear up discarded scales\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  /**\n\t * @private\n\t */\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n\n    this._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    this._updateMetasets();\n    return newControllers;\n  }\n\n  /**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n\n  /**\n\t* Resets the chart back to its state before the initial animation\n\t*/\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const config = this.config;\n\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n\n    // plugins options references might have change, let's invalidate the cache\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n    this._plugins.invalidate();\n\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    // Make sure dataset controllers are updated and new controllers are reset\n    const newControllers = this.buildOrUpdateControllers();\n\n    this.notifyPlugins('beforeElementsUpdate');\n\n    // Make sure all dataset controllers have correct meta data counts\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      // New controllers will be reset after the layout pass, so we only want to modify\n      // elements added to new datasets\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n\n    // Only reset the controllers if we have animations\n    if (!animsDisabled) {\n      // Can only reset the new controllers after the scales have been updated\n      // Reset is done to get the starting point for the initial animation\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n\n    this._updateDatasets(mode);\n\n    // Do this before render so that any plugins that need final scale updates can use it\n    this.notifyPlugins('afterUpdate', {mode});\n\n    this._layers.sort(compare2Level('z', '_idx'));\n\n    // Replay last event from before update, or set hover styles on active elements\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n\n  /**\n   * @private\n   */\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      // The configured events have changed. Rebind.\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n\n  /**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n\n    layouts.update(this, this.width, this.height, minPadding);\n\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\n        return;\n      }\n\n      // configure is called twice, once in core.scale.update and once here.\n      // Here the boxes are fully updated and at their final positions.\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    this.notifyPlugins('afterLayout');\n  }\n\n  /**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n\n  /**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      // Unset pending resize request now to avoid possible recursion within _resize\n      this._resizeBeforeDraw = null;\n      this._resize(width, height);\n    }\n    this.clear();\n\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n    // currently be part of layers. Instead, we draw\n    // layers <= 0 before(default, backward compat), and the rest after\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this._drawDatasets();\n\n    // Rest of layers\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this.notifyPlugins('afterDraw');\n  }\n\n  /**\n\t * @private\n\t */\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n\t * Gets the visible dataset metas in drawing order\n\t * @return {object[]}\n\t */\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  /**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n\n  /**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = getDatasetArea(meta, this.chartArea);\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n\n    meta.controller.draw();\n\n    if (useClip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  /**\n   * Checks whether the given point is in the chart area.\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\n   * @returns {boolean}\n   */\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\t\t\t// See isDatasetVisible() comment\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  /**\n\t * @private\n\t */\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  /**\n\t * @private\n\t */\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n\n    this._stop();\n    this.config.clearCache();\n\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n\n    delete instances[this.id];\n\n    this.notifyPlugins('afterDestroy');\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  /**\n\t * @private\n\t */\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  /**\n   * @private\n   */\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n\n    each(this.options.events, (type) => _add(type, listener));\n  }\n\n  /**\n   * @private\n   */\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n\n    let detached; // eslint-disable-line prefer-const\n    const attached = () => {\n      _remove('attach', attached);\n\n      this.attached = true;\n      this.resize();\n\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      this.attached = false;\n\n      _remove('resize', listener);\n\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\n      this._stop();\n      this._resize(0, 0);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  /**\n\t * Get active (hovered) elements\n\t * @returns array\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active (hovered) elements\n\t * @param {array} activeElements New active data points\n\t */\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      this._active = active;\n      // Make sure we don't use the previous mouse event to override the active elements in update.\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  /**\n\t * Calls enabled plugins on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  /**\n   * Check if a plugin with the specific ID is registered and enabled\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\n   * @returns {boolean}\n   */\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      this.render();\n    }\n\n    return this;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e the event to handle\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\n\t * @return {boolean} true if the chart needs to re-render\n\t * @private\n\t */\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n\n    // If the event is replayed from `update`, we should evaluate with the final positions.\n    //\n    // The `replay`:\n    // It's the last event (excluding click) that has occurred before `update`.\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\n    //\n    // The why:\n    // If animations are active, the elements haven't moved yet compared to state before update.\n    // But if they will, we are activating the elements that would be active, if this check\n    // was done after the animations have completed. => \"final positions\".\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\n    // This is done so we do not have to evaluate the active elements each animation frame\n    // - it would be expensive.\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\n    if (inChartArea) {\n      // Set _lastEvent to null while we are processing the event handlers.\n      // This prevents recursion if the handler calls chart.update()\n      this._lastEvent = null;\n\n      // Invoke onHover hook\n      callCallback(options.onHover, [e, active, this], this);\n\n      if (isClick) {\n        callCallback(options.onClick, [e, active, this], this);\n      }\n    }\n\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n\n    this._lastEvent = lastEvent;\n\n    return changed;\n  }\n\n  /**\n   * @param {ChartEvent} e - The event\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\n   * @param {boolean} inChartArea - Is the event inside chartArea\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\n   * @pravate\n   */\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\n\n// @ts-ignore\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\n\nexport default Chart;\n","import Element from '../core/core.element.js';\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\nimport {PI, _isBetween, _limitValue} from '../helpers/helpers.math.js';\nimport {_readValueToProps} from '../helpers/helpers.options.js';\nimport type {ArcOptions, Point} from '../types/index.js';\n\n\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n\n  // Draw an inner border by clipping the arc and drawing a double-width border\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\n/**\n * Parse border radius from the provided options\n */\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  // Outer limits are complicated. We want to compute the available angular distance at\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n  //\n  // If the borderRadius is large, that value can become negative.\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n  // we know that the thickness term will dominate and compute the limits at that point\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\n\n/**\n * Convert (r, 𝜃) to (x, y)\n */\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\n\n\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */\nfunction pathArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  end: number,\n  circular: boolean,\n) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    // When spacing is present, it is the same for all items\n    // So we adjust the start and end angle of the arc such that\n    // the distance is the same as it would be without the spacing\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\n\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\n  ctx.beginPath();\n\n  if (circular) {\n    // The first arc segments from point 1 to point a to point 2\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n\n    // The corner segment from point 2 to point 3\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n\n    // The line from point 3 to point 4\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n\n    // The corner segment from point 4 to point 5\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n\n    // The inner arc from point 5 to point b to point 6\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\n\n    // The corner segment from point 6 to point 7\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n\n    // The line from point 7 to point 8\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n\n    // The corner segment from point 8 to point 1\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawBorder(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference, options} = element;\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;\n  const inner = options.borderAlign === 'inner';\n\n  if (!borderWidth) {\n    return;\n  }\n\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\n\nexport interface ArcProps extends Point {\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  outerRadius: number;\n  circumference: number;\n}\n\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\n\n  static id = 'arc';\n\n  static defaults = {\n    borderAlign: 'center',\n    borderColor: '#fff',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n  };\n\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor'\n  };\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash'\n  };\n\n  circumference: number;\n  endAngle: number;\n  fullCircles: number;\n  innerRadius: number;\n  outerRadius: number;\n  pixelMargin: number;\n  startAngle: number;\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n    const betweenAngles = _circumference >= TAU || nonZeroBetween;\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\n    return (betweenAngles && withinRadius);\n  }\n\n  getCenterPoint(useFinalPosition: boolean) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius'\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition: boolean) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n\n    ctx.restore();\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\nimport {valueOrDefault} from '../helpers/index.js';\n\n/**\n * @typedef { import('./element.point.js').default } PointElement\n */\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @returns {any}\n */\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  // eslint-disable-next-line prefer-const\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      // Draw line to maxY and minY, using the average x-coordinate\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      // Line to y-value of last point in group. So the line continues\n      // from correct position. Not using move, to have solid path.\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0; // truncated x-coordinate\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      // Draw line to next x-position, using the first (or only)\n      // y-value in that group\n      ctx.lineTo(x, y);\n\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    // Keep track of the last y-value in group\n    lastY = y;\n  }\n  drawX();\n}\n\n/**\n * @param {LineElement} line - the line\n * @returns {function}\n * @private\n */\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\n/**\n * @private\n */\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nexport default class LineElement extends Element {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: 'default',\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n  };\n\n\n  constructor(cfg) {\n    super();\n\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  /**\n\t * First non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  /**\n\t * Last non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  /**\n\t * Interpolate a point in this line at the same value on `property` as\n\t * the reference `point` provided\n\t * @param {PointElement} point - the reference point\n\t * @param {string} property - the property to match on\n\t * @returns {PointElement|undefined}\n\t */\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n\t * Append a segment of this line to current path.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} segment\n\t * @param {number} segment.start - start index of the segment, referring the points array\n \t * @param {number} segment.end - end index of the segment, referring the points array\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\n\t * @param {object} params\n\t * @param {boolean} params.move - move to starting point (vs line to it)\n\t * @param {boolean} params.reverse - path the segment from end to start\n\t * @param {number} params.start - limit segment to points starting from `start` index\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\n\t */\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  /**\n\t * Append all segments of this line to current path.\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\n\t */\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n\n    start = start || 0;\n    count = count || (this.points.length - start);\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n\n  /**\n\t * Draw\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} chartArea\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t */\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n\n    if (points.length && options.borderWidth) {\n      ctx.save();\n\n      draw(ctx, this, start, count);\n\n      ctx.restore();\n    }\n\n    if (this.animated) {\n      // When line is animated, the control points and path are not cached.\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\n","import Element from '../core/core.element.js';\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport type {\n  CartesianParsedData,\n  ChartArea,\n  Point,\n  PointHoverOptions,\n  PointOptions,\n} from '../types/index.js';\n\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\n\nexport type PointProps = Point\n\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\n\n  static id = 'point';\n\n  parsed: CartesianParsedData;\n  skip?: boolean;\n  stop?: boolean;\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: 'circle',\n    radius: 3,\n    rotation: 0\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition?: boolean) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\n    const options = this.options;\n\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    // @ts-expect-error Fallbacks should never be hit in practice\n    return options.radius + options.hitRadius;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\n\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param {BarElement} bar the bar\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\n\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {left, top, right, bottom};\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n\n  // If the value is an object, assume the user knows what they are doing\n  // and apply as directed.\n  const enableBorder = enableBorderRadius || isObject(value);\n\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\n/**\n * Add a path of a rectangle to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nexport default class BarElement extends Element {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderSkipped: 'start',\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: 'auto',\n    pointStyle: undefined\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\n","import {DoughnutController, PolarAreaController, defaults} from '../index.js';\nimport type {Chart, ChartDataset} from '../types.js';\n\nexport interface ColorsPluginOptions {\n  enabled?: boolean;\n  forceOverride?: boolean;\n}\n\ninterface ColorsDescriptor {\n  backgroundColor?: unknown;\n  borderColor?: unknown;\n}\n\nconst BORDER_COLORS = [\n  'rgb(54, 162, 235)', // blue\n  'rgb(255, 99, 132)', // red\n  'rgb(255, 159, 64)', // orange\n  'rgb(255, 205, 86)', // yellow\n  'rgb(75, 192, 192)', // green\n  'rgb(153, 102, 255)', // purple\n  'rgb(201, 203, 207)' // grey\n];\n\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\n\nfunction getBorderColor(i: number) {\n  return BORDER_COLORS[i % BORDER_COLORS.length];\n}\n\nfunction getBackgroundColor(i: number) {\n  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\n\nfunction colorizeDefaultDataset(dataset: ChartDataset, i: number) {\n  dataset.borderColor = getBorderColor(i);\n  dataset.backgroundColor = getBackgroundColor(i);\n\n  return ++i;\n}\n\nfunction colorizeDoughnutDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));\n\n  return i;\n}\n\nfunction colorizePolarAreaDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));\n\n  return i;\n}\n\nfunction getColorizer(chart: Chart) {\n  let i = 0;\n\n  return (dataset: ChartDataset, datasetIndex: number) => {\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n\n    if (controller instanceof DoughnutController) {\n      i = colorizeDoughnutDataset(dataset, i);\n    } else if (controller instanceof PolarAreaController) {\n      i = colorizePolarAreaDataset(dataset, i);\n    } else if (controller) {\n      i = colorizeDefaultDataset(dataset, i);\n    }\n  };\n}\n\nfunction containsColorsDefinitions(\n  descriptors: ColorsDescriptor[] | Record<string, ColorsDescriptor>\n) {\n  let k: number | string;\n\n  for (k in descriptors) {\n    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction containsColorsDefinition(\n  descriptor: ColorsDescriptor\n) {\n  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\n\nfunction containsDefaultColorsDefenitions() {\n  return defaults.borderColor !== 'rgba(0,0,0,0.1)' || defaults.backgroundColor !== 'rgba(0,0,0,0.1)';\n}\n\nexport default {\n  id: 'colors',\n\n  defaults: {\n    enabled: true,\n    forceOverride: false\n  } as ColorsPluginOptions,\n\n  beforeLayout(chart: Chart, _args, options: ColorsPluginOptions) {\n    if (!options.enabled) {\n      return;\n    }\n\n    const {\n      data: {datasets},\n      options: chartOptions\n    } = chart.config;\n    const {elements} = chartOptions;\n\n    const containsColorDefenition = (\n      containsColorsDefinitions(datasets) ||\n      containsColorsDefinition(chartOptions) ||\n      (elements && containsColorsDefinitions(elements)) ||\n      containsDefaultColorsDefenitions());\n\n    if (!options.forceOverride && containsColorDefenition) {\n      return;\n    }\n\n    const colorizer = getColorizer(chart);\n\n    datasets.forEach(colorizer);\n  }\n};\n","import {_limitValue, _lookupByKey, isNullOrUndef, resolve} from '../helpers/index.js';\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  /**\n   * Implementation of the Largest Triangle Three Buckets algorithm.\n   *\n   * This implementation is based on the original implementation by Sveinn Steinarsson\n   * in https://github.com/sveinn-steinarsson/flot-downsample/blob/master/jquery.flot.downsample.js\n   *\n   * The original implementation is MIT licensed.\n   */\n  const samples = options.samples || availableWidth;\n  // There are less points than the threshold, returning the whole array\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n\n  const decimated = [];\n\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  // Starting from offset\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n\n  decimated[sampledIndex++] = data[a];\n\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n\n    // Adding offset\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n\n    // Adding offset\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n\n    // Note that this is changed from the original algorithm which initializes these\n    // values to 1. The reason for this change is that if the area is small, nextA\n    // would never be set and thus a crash would occur in the next loop as `a` would become\n    // `undefined`. Since the area is always positive, but could be 0 in the case of a flat trace,\n    // initializing with a negative number is the correct solution.\n    maxArea = area = -1;\n\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n\n  // Include the last point\n  decimated[sampledIndex++] = data[endIndex];\n\n  return decimated;\n}\n\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      // Use point.x here because we're computing the average data `x` value\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      // Push up to 4 points, 3 for the last interval and the first point for this interval\n      const lastIndex = i - 1;\n\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        // The interval is defined by 4 points: start, min, max, end.\n        // The starting point is already considered at this point, so we need to determine which\n        // of the other points to add. We need to sort these points to ensure the decimated data\n        // is still sorted and then ensure there are no duplicates.\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n\n      // lastIndex === startIndex will occur when a range has only 1 point which could\n      // happen with very uneven data\n      if (i > 0 && lastIndex !== startIndex) {\n        // Last point in the previous interval\n        decimated.push(data[lastIndex]);\n      }\n\n      // Start of the new interval\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n\n  return decimated;\n}\n\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: data,\n    });\n  }\n}\n\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\n\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count;\n\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n\n  return {start, count};\n}\n\nexport default {\n  id: 'decimation',\n\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      // The decimation plugin may have been previously enabled. Need to remove old `dataset._data` handlers\n      cleanDecimatedData(chart);\n      return;\n    }\n\n    // Assume the entire chart is available to show a few more points than needed\n    const availableWidth = chart.width;\n\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        // Decimation is only supported for lines that have an X indexAxis\n        return;\n      }\n\n      if (!meta.controller.supportsDecimation) {\n        // Only line datasets are supported\n        return;\n      }\n\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        // Only linear interpolation is supported\n        return;\n      }\n\n      if (chart.options.parsing) {\n        // Plugin only supports data that does not need parsing\n        return;\n      }\n\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        // No decimation is required until we are above this threshold\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n\n      if (isNullOrUndef(_data)) {\n        // First time we are seeing this dataset\n        // We override the 'data' property with a setter that stores the\n        // raw data in _data, but reads the decimated data from _decimated\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n\n      // Point the chart to the decimated data\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n\n      dataset._decimated = decimated;\n    });\n  },\n\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n","import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\n\nexport function _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      // Special case for boundary not supporting `segments` (simpleArc)\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\n\nexport function _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\n\nexport function _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\n\nexport function _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {isArray} from '../../helpers/index.js';\nimport {_pointsFromSegments} from './filler.segment.js';\n\n/**\n * @param {PointElement[] | { x: number; y: number; }} boundary\n * @param {LineElement} line\n * @return {LineElement?}\n */\nexport function _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    // @ts-ignore\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nexport function _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n","import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.line.js').default } LineElement\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\n */\n\nexport function _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\n/**\n * @param {LineElement} line\n * @param {number} index\n * @param {number} count\n */\nexport function _decodeFill(line, index, count) {\n  /** @type {string | {value: number}} */\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n\n  return target;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @returns {number | null}\n */\nexport function _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @param {number} startValue\n * @returns {number | undefined}\n */\nexport function _getTargetValue(fill, scale, startValue) {\n  let value;\n\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\n\n/**\n * @param {LineElement} line\n */\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {_isBetween} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\n\n/**\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\n * @return {LineElement}\n */\nexport function _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @return {LineElement[]}\n */\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\n\n/**\n * @param {PointElement[]} points\n * @param {PointElement} sourcePoint\n * @param {LineElement[]} linesBelow\n */\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      // First point of an segment -> need to add another point before this,\n      // from next line below.\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        // In the middle of an segment, no need to add more points.\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\n\n/**\n * @param {LineElement} line\n * @param {PointElement} sourcePoint\n * @param {string} property\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\n */\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n","import {TAU} from '../../helpers/index.js';\n\n// TODO: use elements.ArcElement instead\nexport class simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n","import {isFinite} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\nimport {_buildStackLine} from './filler.target.stack.js';\nimport {simpleArc} from './simpleArc.js';\n\n/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nexport function _getTarget(source) {\n  const {chart, fill, line} = source;\n\n  if (isFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n\n  return _createBoundaryLine(boundary, line);\n}\n\n/**\n * @param {Chart} chart\n * @param {number} index\n */\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\n\n\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n\n  if (isFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n\n  return null;\n}\n\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\n","import {clipArea, unclipArea} from '../../helpers/index.js';\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\nimport {_getTarget} from './filler.target.js';\n\nexport function _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n\n  ctx.save();\n\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n\n  ctx.restore();\n}\n\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n\n    ctx.beginPath();\n\n    const lineLoop = !!line.pathSegment(ctx, src);\n\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n\n    ctx.restore();\n  }\n}\n\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\n","/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\nimport LineElement from '../../elements/element.line.js';\nimport {_drawfill} from './filler.drawing.js';\nimport {_shouldApplyFill} from './filler.helper.js';\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\n\nexport default {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n","import defaults from '../core/core.defaults.js';\nimport Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\nimport {\n  _isBetween,\n  callback as call,\n  clipArea,\n  getRtlAdapter,\n  overrideTextDirection,\n  restoreTextDirection,\n  toFont,\n  toPadding,\n  unclipArea,\n  valueOrDefault,\n} from '../helpers/index.js';\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n */\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nexport class Legend extends Element {\n\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this._added = false;\n\n    // Contains hit boxes for each dataset (in dataset order)\n    this.legendHitBoxes = [];\n\n    /**\n \t\t * @private\n \t\t */\n    this._hoveredItem = null;\n\n    // Are we in doughnut mode which has a different data type\n    this.doughnutMode = false;\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n\n    this.legendItems = legendItems;\n  }\n\n  fit() {\n    const {options, ctx} = this;\n\n    // The legend may not be displayed for a variety of reasons including\n    // the fact that the defaults got set to `false`.\n    // When the legend is not displayed, there are no guarantees that the options\n    // are correctly formatted so we need to bail out as early as possible.\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    let width, height;\n\n    ctx.font = labelFont.string;\n\n    if (this.isHorizontal()) {\n      width = this.maxWidth; // fill all the width\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight; // fill all the height\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n\n  /**\n\t * @private\n\t */\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n\n    let left = 0;\n    let col = 0;\n\n    this.legendItems.forEach((legendItem, i) => {\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n\n      // If too tall, go to new column\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      // Store the hitbox width and height here. Final position will be updated in `draw`\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\n      // Get max width\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n\n      this._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n\n    this.drawTitle();\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    // current position\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      // Set the ctx for the box\n      ctx.save();\n\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        // Recalculate x and y for drawPoint() because its expecting\n        // x and y to be center of figure (instead of top left)\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n\n        // Draw pointStyle as legend symbol\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        // Draw box as legend symbol\n        // Adjust position when boxHeight < fontSize (want it centered)\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    // Horizontal\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(this.ctx, opts.textDirection);\n\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\n\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n\n      rtlHelper.setWidth(this.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n\n      drawLegendBox(realX, y, legendItem);\n\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\n      // Fill the actual label\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== 'string') {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n\n    // These defaults are used when the legend is vertical.\n    // When horizontal, they are computed below.\n    let left = this.left;\n    let maxWidth = this.width;\n\n    if (this.isHorizontal()) {\n      // Move left / right so that the title is above the legend lines\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      // Move down so that the title is above the legend stack in every alignment\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n\n    // Now that we know the left edge of the inner legend box, compute the correct\n    // X coordinate from the title alignment\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  /**\n\t * @private\n\t */\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      // See if we are touching one of the dataset boxes\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          // Touching an element\n          return this.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t */\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    // Chart event already has relative position in it\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        call(opts.onLeave, [e, previous, this], this);\n      }\n\n      this._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        call(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      call(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\n\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {itemWidth, itemHeight};\n}\n\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== 'string') {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\n}\n\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== 'string') {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\n\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\n\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\n\nexport default {\n  id: 'legend',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  // During the beforeUpdate step, the layout configuration needs to run\n  // This ensures that if the legend position changes (via an option update)\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  // The labels need to be built after datasets are updated to ensure that colors\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    // a callback that will handle\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n\n            // Below is extra data used for toggling the datasets\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n","import Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\nimport {renderText} from '../helpers/helpers.canvas.js';\n\nexport class Title extends Element {\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n\n    this.left = 0;\n    this.top = 0;\n\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nexport default {\n  id: 'title',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000         // by default greater than legend (1000) to be above\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import {Title} from './plugin.title.js';\nimport layouts from '../core/core.layouts.js';\n\nconst map = new WeakMap();\n\nexport default {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import Animations from '../core/core.animations.js';\nimport Element from '../core/core.element.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\nimport {createContext, drawPoint} from '../helpers/index.js';\n\n/**\n * @typedef { import('../platform/platform.base.js').Chart } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\n */\n\nconst positioners = {\n  /**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t */\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let xSet = new Set();\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        xSet.add(pos.x);\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    // No visible items where found, return false so we don't have to divide by 0 which reduces in NaN\n    if (count === 0 || xSet.size === 0) {\n      return false;\n    }\n\n    const xAverage = [...xSet].reduce((a, b) => a + b) / xSet.size;\n\n    return {\n      x: xAverage,\n      y: y / count\n    };\n  },\n\n  /**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t */\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      // base = base.concat(toPush);\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {*} str - The value to split by newline.\n * @returns {string|string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param {Chart} chart\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n\n  // Count of all lines in the body\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    // Body lines may include some extra height depending on boxHeight\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  // Title width\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n\n  // Body width\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\n  // Body lines may include some extra width due to the color box\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n\n  // Reset back to 0\n  widthPadding = 0;\n\n  // Footer width\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n\n  ctx.restore();\n\n  // Add padding\n  width += padding.width;\n\n  return {width, height};\n}\n\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  // eslint-disable-next-line prefer-const\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nconst defaultCallbacks = {\n  // Args are: (tooltipItems, data)\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n\n      if (this && this.options && this.options.mode === 'dataset') {\n        return item.dataset.label || '';\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n\n    return '';\n  },\n  afterTitle: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeBody: noop,\n\n  // Args are: (tooltipItem, data)\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === 'dataset') {\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n\n    let label = tooltipItem.dataset.label || '';\n\n    if (label) {\n      label += ': ';\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0,\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation,\n    };\n  },\n  afterLabel: noop,\n\n  // Args are: (tooltipItems, data)\n  afterBody: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\n\n/**\n * Invoke callback from object with context and arguments.\n * If callback returns `undefined`, then will be invoked default callback.\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\n * @param {keyof typeof defaultCallbacks} name\n * @param {*} ctx\n * @param {*} arg\n * @returns {any}\n */\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n\n  if (typeof result === 'undefined') {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n\n  return result;\n}\n\nexport class Tooltip extends Element {\n\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n  static positioners = positioners;\n\n  constructor(config) {\n    super();\n\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\n    // and `labelTextColors` to create a single variable\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const {callbacks} = options;\n\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\n    );\n  }\n\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n\n      bodyItems.push(bodyItem);\n    });\n\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\n    );\n  }\n\n  // Get the footer and beforeFooter and afterFooter lines\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n    return lines;\n  }\n\n  /**\n\t * @private\n\t */\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n\n    // If the user provided a filter function, use it to modify the tooltip items\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    // If the user provided a sorting function, use it to modify the tooltip items\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    // Determine colors for boxes\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n    });\n\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n\n        // Left draws bottom -> top, this y1 is on the bottom\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n\n        // Right draws top -> bottom, thus y1 is on the top\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n\n        // Top draws left -> right, thus x1 is on the left\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n\n        // Bottom draws right -> left, thus x1 is on the right\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.titleAlign, options);\n\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n        }\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      // Recalculate x and y for drawPoint() because its expecting\n      // x and y to be center of figure (instead of top left)\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n\n      // Draw the point\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      // Border\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        // Normal rect\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    // restore fillStyle\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\n    // Before body lines\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n\n    // Draw body lines now\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n\n      lines = bodyItem.lines;\n      // Draw Legend-like boxes if needed\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        // Reset for any lines that don't include colorbox\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n\n    // After body lines\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n\n      footerFont = toFont(options.footerFont);\n\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  /**\n\t * Update x/y animation targets when _active elements are animating too\n\t * @private\n\t */\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n\n  /**\n   * Determine if the tooltip will draw anything\n   * @returns {boolean} True if the tooltip will render\n   */\n  _willRender() {\n    return !!this.opacity;\n  }\n\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    this._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n\n    // IE11/Edge does not like very small opacities, so snap to 0\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\n    const padding = toPadding(options.padding);\n\n    // Truthy/falsey value for empty tooltip\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n\n      // Draw Background\n      this.drawBackground(pt, ctx, tooltipSize, options);\n\n      overrideTextDirection(ctx, options.textDirection);\n\n      pt.y += padding.top;\n\n      // Titles\n      this.drawTitle(pt, ctx, options);\n\n      // Body\n      this.drawBody(pt, ctx, options);\n\n      // Footer\n      this.drawFooter(pt, ctx, options);\n\n      restoreTextDirection(ctx, options.textDirection);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * Get active elements in the tooltip\n\t * @returns {Array} Array of elements that are active in the tooltip\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active elements in the tooltip\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\n\t * @param {object} eventPosition Synthetic event position used in positioning\n\t */\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {boolean} true if the tooltip changed\n\t */\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\n    // When there are multiple items shown, but the tooltip position is nearest mode\n    // an update may need to be made because our position may have changed even though\n    // the items are the same as before.\n    const positionChanged = this._positionChanged(active, e);\n\n    // Remember Last Actives\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    // Only handle target event on tooltip change\n    if (changed) {\n      this._active = active;\n\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n\n        this.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n\t * Helper for determining the active elements for event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {InteractionItem[]} lastActive - Previously active elements\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {InteractionItem[]} - Active elements\n\t * @private\n\t */\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      // But make sure that active elements are still valid.\n      return lastActive.filter(i =>\n        this.chart.data.datasets[i.datasetIndex] &&\n        this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined\n      );\n    }\n\n    // Find Active Elements for tooltips\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n    if (options.reverse) {\n      active.reverse();\n    }\n\n    return active;\n  }\n\n  /**\n\t * Determine if the active elements + event combination changes the\n\t * tooltip position\n\t * @param {array} active - Active elements\n\t * @param {ChartEvent} e - Event that triggered the position change\n\t * @returns {boolean} True if the position has changed\n\t */\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\n\nexport default {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\n        return;\n      }\n\n      tooltip.draw(chart.ctx);\n\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      // If the event is replayed from `update`, we should evaluate with the final positions.\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        // notify chart about the change, so it will render\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n\n  // Resolve additionally from `interaction` options and defaults.\n  additionalOptionScopes: ['interaction']\n};\n","import Scale from '../core/core.scale.js';\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\n\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\n\nexport default class CategoryScale extends Scale {\n\n  static id = 'category';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n\n    // If we are viewing some subset of labels, slice the original array\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    super.configure();\n\n    if (!this.isHorizontal()) {\n      // For backward compatibility, vertical category scale reverse is inverted.\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n\n  // Used to get data value locations. Value can either be an index or a numerical value\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  // Must override base implementation because it calls getPixelForValue\n  // and category scale can have duplicate values\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n}\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\n\n/**\n * Generate a set of linear ticks for an axis\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\n *    Note that the generationOptions.maxCount setting is respected in this scenario\n *\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\n *    spacing = (max - min) / count\n *    Ticks are generated as [min, min + spacing, ..., max]\n *\n * 3. If generationOptions.count is defined\n *    spacing = (niceMax - niceMin) / count\n *\n * 4. Compute optimal spacing of ticks using niceNum algorithm\n *\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, dataRange) {\n  const ticks = [];\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  // Beyond MIN_SPACING floating point numbers being to lose precision\n  // such that we can't do the math necessary to generate ticks\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    // If the user specified a precision, round to that number of decimal places\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\n    // spacing = step;\n    // numSpaces = (max - min) / spacing;\n    // Note that we round here to handle the case where almostWhole translated an FP error\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\n    // Sometimes these are no-ops, but it makes the code a lot clearer\n    // and when a user defined range is specified, we want the correct ticks\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    // Case 4\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    // If very close to our rounded value, use it.\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\n  // until this point\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n\n      if (niceMin < min) {\n        j++; // Skip niceMin\n      }\n      // If the next nice tick is close to min, skip it\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({value: tickValue});\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    // If the previous tick is too close to max, replace it with max, else add max\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nexport default class LinearScaleBase extends Scale {\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    /** @type {number} */\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    // eslint-disable-next-line prefer-const\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  /**\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    // Figure out what the max number of ticks we can support it is based on the size of\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n    // the graph. Make sure we always have at least 2 ticks\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n\n    super.configure();\n\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n","import {isFinite} from '../helpers/helpers.core.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {toRadians} from '../helpers/index.js';\n\nexport default class LinearScale extends LinearScaleBase {\n\n  static id = 'linear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? min : 0;\n    this.max = isFinite(max) ? max : 1;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n \t */\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  // Utils\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\n\nconst log10Floor = v => Math.floor(log10(v));\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\n  return remain === 1;\n}\n\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\n\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\n\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, {min, max}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({value, major: isMajor(value), significand});\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\n\n  return ticks;\n}\n\nexport default class LogarithmicScale extends Scale {\n\n  static id = 'logarithmic';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? Math.max(0, min) : null;\n    this.max = isFinite(max) ? Math.max(0, max) : null;\n\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n\n    this.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (min === max) {\n      if (min <= 0) { // includes null\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n\n      setMax(changeExponent(min, +1));\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const start = this.min;\n\n    super.configure();\n\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\n","import defaults from '../core/core.defaults.js';\nimport {_longestText, addRoundedRectPath, renderText, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n  // Right, this is really confusing and there is a lot of maths going on here\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n  //\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n  //\n  // Solution:\n  //\n  // We assume the radius of the polygon is half the size of the canvas at first\n  // at each index we check if the text overlaps.\n  //\n  // Where it does, we store that angle and that index.\n  //\n  // After finding the largest index and angle we calculate how much we need to remove\n  // from the shape radius to move the point inwards by that x.\n  //\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\n  // along with labels.\n  //\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\n  //\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n  // and position it in the most space efficient manner\n  //\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n\n  // Now that text size is determined, compute the full positions\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\n\nfunction createPointLabelItem(scale, index, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {extra, additionalAngle, padding, size} = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    // if to draw or overlapped\n    visible: true,\n\n    // Text position\n    x: pointLabelPosition.x,\n    y,\n\n    // Text rendering data\n    textAlign,\n\n    // Bounding box\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\n\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {left, top, right, bottom} = item;\n  const apexesInArea = _isPointInArea({x: left, y: top}, area) || _isPointInArea({x: left, y: bottom}, area) ||\n    _isPointInArea({x: right, y: top}, area) || _isPointInArea({x: right, y: bottom}, area);\n  return !apexesInArea;\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {centerPointLabels, display} = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === 'auto') {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\n\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {left, top, right, bottom} = item;\n  const {backdropColor} = opts;\n\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n\n    if (Object.values(borderRadius).some(v => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius,\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      // overlapping\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign} = item;\n\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    // Draw circular arcs between the points\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    // Draw straight lines connecting each index\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n\n  const {color, lineWidth} = gridLineOpts;\n\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash || []);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nexport default class RadialLinearScale extends LinearScaleBase {\n\n  static id = 'radialLinear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    display: true,\n\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n\n    grid: {\n      circular: false\n    },\n\n    startAngle: 0,\n\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n\n      callback: Ticks.formatters.numeric\n    },\n\n    pointLabels: {\n      backdropColor: undefined,\n\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPadding: 2,\n\n      // Boolean - if true, show point labels\n      display: true,\n\n      // Number - Point label font size in pixels\n      font: {\n        size: 10\n      },\n\n      // Function - Used to convert point labels\n      callback(label) {\n        return label;\n      },\n\n      // Number - Additionl padding between scale and pointLabel\n      padding: 5,\n\n      // Boolean - if true, center point labels to slices in polar chart\n      centerPointLabels: false\n    }\n  };\n\n  static defaultRoutes = {\n    'angleLines.color': 'borderColor',\n    'pointLabels.color': 'color',\n    'ticks.color': 'color'\n  };\n\n  static descriptors = {\n    angleLines: {\n      _fallback: 'grid'\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.xCenter = undefined;\n    /** @type {number} */\n    this.yCenter = undefined;\n    /** @type {number} */\n    this.drawingArea = undefined;\n    /** @type {string[]} */\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\n    // Point labels\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n\n  fit() {\n    const opts = this.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    // Take into account half font size + the yPadding of the top value\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid, border} = opts;\n    const labelCount = this._pointLabels.length;\n\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0 || (index === 0 && this.min < 0)) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\n        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {}\n\n  /**\n\t * @protected\n\t */\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    this.ticks.forEach((tick, index) => {\n      if ((index === 0 && this.min >= 0) && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth,\n      });\n    });\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {}\n}\n","import adapters from '../core/core.adapters.js';\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\n\n/**\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\n */\n\n/**\n * @type {Object<Unit, Interval>}\n */\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\n\n/**\n * @type {Unit[]}\n */\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\n\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction sorter(a, b) {\n  return a - b;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {*} input\n * @return {number}\n */\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  // Only parse if it's not a timestamp already\n  if (!isFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, /** @type {Unit} */ (parser))\n      : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @param {number} capacity\n * @return {object}\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n * @param {TimeScale} scale\n * @param {number} numTicks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @return {Unit}\n */\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\n/**\n * @param {Unit} unit\n * @return {object}\n */\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\n/**\n * @param {object} ticks\n * @param {number} time\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\n */\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\n/**\n * @param {TimeScale} scale\n * @param {object[]} ticks\n * @param {object} map\n * @param {Unit} majorUnit\n * @return {object[]}\n */\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {number[]} values\n * @param {Unit|undefined} [majorUnit]\n * @return {object[]}\n */\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  /** @type {Object<number,object>} */\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  // We set the major ticks separately from the above loop because calling startOf for every tick\n  // is expensive when there is a large number of ticks\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nexport default class TimeScale extends Scale {\n\n  static id = 'time';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n\n    adapters: {},\n    time: {\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\n      unit: false, // false == automatic or override with week, month, year, etc.\n      round: false, // none, or override with week, month, year, etc.\n      isoWeekday: false, // override week start day\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n\n      callback: false,\n\n      major: {\n        enabled: false\n      }\n    }\n  };\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {{data: number[], labels: number[], all: number[]}} */\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n\n    /** @type {Unit} */\n    this._unit = 'day';\n    /** @type {Unit=} */\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    /** @type {DateAdapter} */\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\n    adapter.init(opts);\n\n    // Backward compatibility: before introducing adapter, `displayFormats` was\n    // supposed to contain *all* unit/string pairs but this can't be resolved\n    // when loading the scale (adapters are loaded afterward), so let's populate\n    // missing formats on update\n    mergeIf(time.displayFormats, adapter.formats());\n\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n\n    super.init(scaleOpts);\n\n    this._normalized = opts.normalized;\n  }\n\n  /**\n\t * @param {*} raw\n\t * @param {number?} [index]\n\t * @return {number}\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\n    /**\n\t\t * @param {object} bounds\n\t\t */\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\n    if (!minDefined || !maxDefined) {\n      // Labels are always considered, when user did not force bounds\n      _applyBounds(this._getLabelBounds());\n\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\n      // data bounds are ignored (and don't need to be determined)\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n\n  /**\n\t * @private\n\t */\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n\n  /**\n\t * @return {object[]}\n\t */\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = this.min;\n    const max = this.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    // PRIVATE\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n\n  afterAutoSkip() {\n    // Offsets for bar charts need to be handled with the auto skipped\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n\n  /**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t * @param {number[]} timestamps\n\t * @protected\n\t */\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n\n  /**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t * @protected\n\t */\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    // @ts-ignore\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    // For 'week' unit, handle the first day of week option\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    // Align first ticks on unit\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    // Prevent browser from freezing in case user options request millions of milliseconds\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    // @ts-ignore\n    return Object.keys(ticks).sort(sorter).map(x => +x);\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  /**\n\t * @param {number} value\n\t * @param {string|undefined} format\n\t * @return {string}\n\t */\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n\n  /**\n\t * Function to format an individual tick mark\n\t * @param {number} time\n\t * @param {number} index\n\t * @param {object[]} ticks\n\t * @param {string|undefined} [format]\n\t * @return {string}\n\t * @private\n\t */\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n\n    if (formatter) {\n      return call(formatter, [time, index, ticks], this);\n    }\n\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n\n  /**\n\t * @param {object[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n\n  /**\n\t * @param {string} label\n\t * @return {{w:number, h:number}}\n\t * @private\n\t */\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n\n  /**\n\t * @param {number} exampleTime\n\t * @return {number}\n\t * @private\n\t */\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n\n    // pick the longest format (milliseconds) for guesstimation\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    // subtract 1 - if offset then there's one less label than tick\n    // if not offset then one half label padding is added to each end leaving room for one less label\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n\n    return (this._cache.data = this.normalize(timestamps));\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n\n  /**\n\t * @param {number[]} values\n\t * @protected\n\t */\n  normalize(values) {\n    // It seems to be somewhat faster to do sorting first\n    return _arrayUnique(values.sort(sorter));\n  }\n}\n","import TimeScale from './scale.time.js';\nimport {_lookupByKey} from '../helpers/helpers.collection.js';\n\n/**\n * Linearly interpolates the given source `val` using the table. If value is out of bounds, values\n * at edges are used for the interpolation.\n * @param {object} table\n * @param {number} val\n * @param {boolean} [reverse] lookup time based on position instead of vice versa\n * @return {object}\n */\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\n\nclass TimeSeriesScale extends TimeScale {\n\n  static id = 'timeseries';\n\n  /**\n   * @type {any}\n   */\n  static defaults = TimeScale.defaults;\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {object[]} */\n    this._table = [];\n    /** @type {number} */\n    this._minPos = undefined;\n    /** @type {number} */\n    this._tableRange = undefined;\n  }\n\n  /**\n\t * @protected\n\t */\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n\n  /**\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n\t * @param {number[]} timestamps\n\t * @return {object[]}\n\t * @protected\n\t */\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n\n    if (items.length < 2) {\n      // In case there is less that 2 timestamps between min and max, the scale is defined by min and max\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n\n      // only add points that breaks the scale linearity\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n\n  /**\n    * Generates all timestamps defined in the data.\n    * Important: this method can return ticks outside the min and max range, it's the\n    * responsibility of the calling code to clamp values if needed.\n    * @protected\n    */\n  _generate() {\n    const min = this.min;\n    const max = this.max;\n    let timestamps = super.getDataTimestamps();\n    if (!timestamps.includes(min) || !timestamps.length) {\n      timestamps.splice(0, 0, min);\n    }\n    if (!timestamps.includes(max) || timestamps.length === 1) {\n      timestamps.push(max);\n    }\n    return timestamps.sort((a, b) => a - b);\n  }\n\n  /**\n\t * Returns all timestamps\n\t * @return {number[]}\n\t * @private\n\t */\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      // If combining labels and data (data might not contain all labels),\n      // we need to recheck uniqueness and sort\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n\n    return timestamps;\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\n\nexport default TimeSeriesScale;\n","export * from './controllers/index.js';\nexport * from './core/index.js';\nexport * from './elements/index.js';\nexport * from './platform/index.js';\nexport * from './plugins/index.js';\nexport * from './scales/index.js';\n\nimport * as controllers from './controllers/index.js';\nimport * as elements from './elements/index.js';\nimport * as plugins from './plugins/index.js';\nimport * as scales from './scales/index.js';\n\nexport {\n  controllers,\n  elements,\n  plugins,\n  scales,\n};\n\nexport const registerables = [\n  controllers,\n  elements,\n  plugins,\n  scales,\n];\n","/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names$1 = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    clip: true,\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas?: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  if (!ctx && !canvas) {\n    return;\n  }\n\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bézier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import type {ChartArea, Scale} from '../types/index.js';\nimport type Chart from '../core/core.controller.js';\nimport type {ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  chart.height = Math.floor(chart.height);\n  chart.width = Math.floor(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    if (_isDomSupported()) {\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    }\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n","/*!\n* chartjs-plugin-annotation v3.1.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2024 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, DoughnutController, defaults, Animations, Chart } from 'chart.js';\nimport { distanceBetweenPoints, toRadians, isObject, valueOrDefault, defined, isFunction, callback, isArray, toFont, addRoundedRectPath, toTRBLCorners, QUARTER_PI, PI, HALF_PI, TWO_THIRDS_PI, TAU, isNumber, RAD_PER_DEG, toPadding, isFinite, getAngleFromPoint, toDegrees, clipArea, unclipArea } from 'chart.js/helpers';\n\n/**\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst interaction = {\n  modes: {\n    /**\n     * Point mode returns all elements that hit test based on the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    point(visibleElements, event) {\n      return filterElements(visibleElements, event, {intersect: true});\n    },\n\n    /**\n     * Nearest mode returns the element closest to the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\n     */\n    nearest(visibleElements, event, options) {\n      return getNearestItem(visibleElements, event, options);\n    },\n    /**\n     * x mode returns the elements that hit-test at the current x coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    x(visibleElements, event, options) {\n      return filterElements(visibleElements, event, {intersect: options.intersect, axis: 'x'});\n    },\n\n    /**\n     * y mode returns the elements that hit-test at the current y coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    y(visibleElements, event, options) {\n      return filterElements(visibleElements, event, {intersect: options.intersect, axis: 'y'});\n    }\n  }\n};\n\n/**\n * Returns all elements that hit test based on the event position\n * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n * @param {ChartEvent} event - the event we are find things at\n * @param {Object} options - interaction options to use\n * @return {AnnotationElement[]} - elements that are found\n */\nfunction getElements(visibleElements, event, options) {\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\n  return mode(visibleElements, event, options);\n}\n\nfunction inRangeByAxis(element, event, axis) {\n  if (axis !== 'x' && axis !== 'y') {\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\n  }\n  return element.inRange(event.x, event.y, axis, true);\n}\n\nfunction getPointByAxis(event, center, axis) {\n  if (axis === 'x') {\n    return {x: event.x, y: center.y};\n  } else if (axis === 'y') {\n    return {x: center.x, y: event.y};\n  }\n  return center;\n}\n\nfunction filterElements(visibleElements, event, options) {\n  return visibleElements.filter((element) => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\n}\n\nfunction getNearestItem(visibleElements, event, options) {\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  return filterElements(visibleElements, event, options)\n    .reduce((nearestItems, element) => {\n      const center = element.getCenterPoint();\n      const evenPoint = getPointByAxis(event, center, options.axis);\n      const distance = distanceBetweenPoints(event, evenPoint);\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n\n      return nearestItems;\n    }, [])\n    .sort((a, b) => a._index - b._index)\n    .slice(0, 1); // return only the top item;\n}\n\n/**\n * @typedef {import('chart.js').Point} Point\n */\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {Point} point - the point to rotate\n * @param {Point} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {Point} rotated point\n */\nfunction rotated(point, center, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const cx = center.x;\n  const cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nconst isOlderPart = (act, req) => req > act || (act.length > req.length && act.slice(0, req.length) === req);\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst EPSILON = 0.001;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\n/**\n * @param {{value: number, start: number, end: number}} limit\n * @param {number} hitSize\n * @returns {boolean}\n */\nconst inLimit = (limit, hitSize) => limit.value >= limit.start - hitSize && limit.value <= limit.end + hitSize;\n\n/**\n * @param {Object} obj\n * @param {number} from\n * @param {number} to\n * @returns {Object}\n */\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\n/**\n * @param {Point} point\n * @param {Point} center\n * @param {number} radius\n * @param {number} hitSize\n * @returns {boolean}\n */\nfunction inPointRange(point, center, radius, hitSize) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n  return (Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)) <= Math.pow(radius + hitSize, 2);\n}\n\n/**\n * @param {Point} point\n * @param {{x: number, y: number, x2: number, y2: number}} rect\n * @param {InteractionAxis} axis\n * @param {{borderWidth: number, hitTolerance: number}} hitsize\n * @returns {boolean}\n */\nfunction inBoxRange(point, {x, y, x2, y2}, axis, {borderWidth, hitTolerance}) {\n  const hitSize = (borderWidth + hitTolerance) / 2;\n  const inRangeX = point.x >= x - hitSize - EPSILON && point.x <= x2 + hitSize + EPSILON;\n  const inRangeY = point.y >= y - hitSize - EPSILON && point.y <= y2 + hitSize + EPSILON;\n  if (axis === 'x') {\n    return inRangeX;\n  } else if (axis === 'y') {\n    return inRangeY;\n  }\n  return inRangeX && inRangeY;\n}\n\n/**\n * @param {Point} point\n * @param {rect: {x: number, y: number, x2: number, y2: number}, center: {x: number, y: number}} element\n * @param {InteractionAxis} axis\n * @param {{rotation: number, borderWidth: number, hitTolerance: number}}\n * @returns {boolean}\n */\nfunction inLabelRange(point, {rect, center}, axis, {rotation, borderWidth, hitTolerance}) {\n  const rotPoint = rotated(point, center, toRadians(-rotation));\n  return inBoxRange(rotPoint, rect, axis, {borderWidth, hitTolerance});\n}\n\n/**\n * @param {AnnotationElement} element\n * @param {boolean} useFinalPosition\n * @returns {Point}\n */\nfunction getElementCenterPoint(element, useFinalPosition) {\n  const {centerX, centerY} = element.getProps(['centerX', 'centerY'], useFinalPosition);\n  return {x: centerX, y: centerY};\n}\n\n/**\n * @param {string} pkg\n * @param {string} min\n * @param {string} ver\n * @param {boolean} [strict=true]\n * @returns {boolean}\n */\nfunction requireVersion(pkg, min, ver, strict = true) {\n  const parts = ver.split('.');\n  let i = 0;\n  for (const req of min.split('.')) {\n    const act = parts[i++];\n    if (parseInt(req, 10) < parseInt(act, 10)) {\n      break;\n    }\n    if (isOlderPart(act, req)) {\n      if (strict) {\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nconst isPercentString = (s) => typeof s === 'string' && s.endsWith('%');\nconst toPercent = (s) => parseFloat(s) / 100;\nconst toPositivePercent = (s) => clamp(toPercent(s), 0, 1);\n\nconst boxAppering = (x, y) => ({x, y, x2: x, y2: y, width: 0, height: 0});\nconst defaultInitAnimation = {\n  box: (properties) => boxAppering(properties.centerX, properties.centerY),\n  doughnutLabel: (properties) => boxAppering(properties.centerX, properties.centerY),\n  ellipse: (properties) => ({centerX: properties.centerX, centerY: properties.centerX, radius: 0, width: 0, height: 0}),\n  label: (properties) => boxAppering(properties.centerX, properties.centerY),\n  line: (properties) => boxAppering(properties.x, properties.y),\n  point: (properties) => ({centerX: properties.centerX, centerY: properties.centerY, radius: 0, width: 0, height: 0}),\n  polygon: (properties) => boxAppering(properties.centerX, properties.centerY)\n};\n\n/**\n * @typedef { import('chart.js').FontSpec } FontSpec\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').Padding } Padding\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\n */\n\n/**\n * @param {number} size\n * @param {number|string} position\n * @returns {number}\n */\nfunction getRelativePosition(size, position) {\n  if (position === 'start') {\n    return 0;\n  }\n  if (position === 'end') {\n    return size;\n  }\n  if (isPercentString(position)) {\n    return toPositivePercent(position) * size;\n  }\n  return size / 2;\n}\n\n/**\n * @param {number} size\n * @param {number|string} value\n * @param {boolean} [positivePercent=true]\n * @returns {number}\n */\nfunction getSize(size, value, positivePercent = true) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return (positivePercent ? toPositivePercent(value) : toPercent(value)) * size;\n  }\n  return size;\n}\n\n/**\n * @param {{x: number, width: number}} size\n * @param {CoreLabelOptions} options\n * @returns {number}\n */\nfunction calculateTextAlignment(size, options) {\n  const {x, width} = size;\n  const textAlign = options.textAlign;\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n  return x;\n}\n\n/**\n * @param {Point} point\n * @param {{height: number, width: number}} labelSize\n * @param {{borderWidth: number, position: {LabelPositionObject|string}, xAdjust: number, yAdjust: number}} options\n * @param {Padding|undefined} padding\n * @returns {{x: number, y: number, x2: number, y2: number, height: number, width: number, centerX: number, centerY: number}}\n */\nfunction measureLabelRectangle(point, labelSize, {borderWidth, position, xAdjust, yAdjust}, padding) {\n  const hasPadding = isObject(padding);\n  const width = labelSize.width + (hasPadding ? padding.width : 0) + borderWidth;\n  const height = labelSize.height + (hasPadding ? padding.height : 0) + borderWidth;\n  const positionObj = toPosition(position);\n  const x = calculateLabelPosition$1(point.x, width, xAdjust, positionObj.x);\n  const y = calculateLabelPosition$1(point.y, height, yAdjust, positionObj.y);\n\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2\n  };\n}\n\n/**\n * @param {LabelPositionObject|string} value\n * @param {string|number} defaultValue\n * @returns {LabelPositionObject}\n */\nfunction toPosition(value, defaultValue = 'center') {\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, defaultValue),\n      y: valueOrDefault(value.y, defaultValue),\n    };\n  }\n  value = valueOrDefault(value, defaultValue);\n  return {\n    x: value,\n    y: value\n  };\n}\n\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {boolean}\n */\nconst shouldFit = (options, fitRatio) => options && options.autoFit && fitRatio < 1;\n\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {FontSpec[]}\n */\nfunction toFonts(options, fitRatio) {\n  const optFont = options.font;\n  const fonts = isArray(optFont) ? optFont : [optFont];\n  if (shouldFit(options, fitRatio)) {\n    return fonts.map(function(f) {\n      const font = toFont(f);\n      font.size = Math.floor(f.size * fitRatio);\n      font.lineHeight = f.lineHeight;\n      return toFont(font);\n    });\n  }\n  return fonts.map(f => toFont(f));\n}\n\n/**\n * @param {AnnotationPointCoordinates} options\n * @returns {boolean}\n */\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\n\nfunction calculateLabelPosition$1(start, size, adjust = 0, position) {\n  return start - getRelativePosition(size, position) + adjust;\n}\n\n/**\n * @param {Chart} chart\n * @param {AnnotationBoxModel} properties\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationElement}\n */\nfunction initAnimationProperties(chart, properties, options) {\n  const initAnim = options.init;\n  if (!initAnim) {\n    return;\n  } else if (initAnim === true) {\n    return applyDefault(properties, options);\n  }\n  return execCallback(chart, properties, options);\n}\n\n/**\n * @param {Object} options\n * @param {Array} hooks\n * @param {Object} hooksContainer\n * @returns {boolean}\n */\nfunction loadHooks(options, hooks, hooksContainer) {\n  let activated = false;\n  hooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      activated = true;\n      hooksContainer[hook] = options[hook];\n    } else if (defined(hooksContainer[hook])) {\n      delete hooksContainer[hook];\n    }\n  });\n  return activated;\n}\n\nfunction applyDefault(properties, options) {\n  const type = options.type || 'line';\n  return defaultInitAnimation[type](properties);\n}\n\nfunction execCallback(chart, properties, options) {\n  const result = callback(options.init, [{chart, properties, options}]);\n  if (result === true) {\n    return applyDefault(properties, options);\n  } else if (isObject(result)) {\n    return result;\n  }\n}\n\nconst widthCache = new Map();\nconst notRadius = (radius) => isNaN(radius) || radius <= 0;\nconst fontsKey = (fonts) => fonts.reduce(function(prev, item) {\n  prev += item.string;\n  return prev;\n}, '');\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n */\n\n/**\n * Determine if content is an image or a canvas.\n * @param {*} content\n * @returns boolean|undefined\n * @todo move this function to chart.js helpers\n */\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    const type = content.toString();\n    return (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]');\n  }\n}\n\n/**\n * Set the translation on the canvas if the rotation must be applied.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Point} point - the point of translation\n * @param {number} rotation - rotation (in degrees) to apply\n */\nfunction translate(ctx, {x, y}, rotation) {\n  if (rotation) {\n    ctx.translate(x, y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-x, -y);\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n * @returns {boolean|undefined}\n */\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle || 'butt';\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle || 'miter';\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n */\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {CoreLabelOptions} options\n * @returns {{width: number, height: number}}\n */\nfunction measureLabelSize(ctx, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    const size = {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n    return size;\n  }\n  const fonts = toFonts(options);\n  const strokeWidth = options.textStrokeWidth;\n  const lines = isArray(content) ? content : [content];\n  const mapKey = lines.join() + fontsKey(fonts) + strokeWidth + (ctx._measureText ? '-spriting' : '');\n  if (!widthCache.has(mapKey)) {\n    widthCache.set(mapKey, calculateLabelSize(ctx, lines, fonts, strokeWidth));\n  }\n  return widthCache.get(mapKey);\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {Object} options\n */\nfunction drawBox(ctx, rect, options) {\n  const {x, y, width, height} = rect;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x, y, w: width, h: height,\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n */\nfunction drawLabel(ctx, rect, options, fitRatio) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    ctx.save();\n    ctx.globalAlpha = getOpacity(options.opacity, content.style.opacity);\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    ctx.restore();\n    return;\n  }\n  const labels = isArray(content) ? content : [content];\n  const fonts = toFonts(options, fitRatio);\n  const optColor = options.color;\n  const colors = isArray(optColor) ? optColor : [optColor];\n  const x = calculateTextAlignment(rect, options);\n  const y = rect.y + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n  if (setTextStrokeStyle(ctx, options)) {\n    applyLabelDecoration(ctx, {x, y}, labels, fonts);\n  }\n  applyLabelContent(ctx, {x, y}, labels, {fonts, colors});\n  ctx.restore();\n}\n\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{radius: number, options: PointAnnotationOptions}} element\n * @param {number} x\n * @param {number} y\n */\nfunction drawPoint(ctx, element, x, y) {\n  const {radius, options} = element;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (isImageOrCanvas(style)) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rad);\n    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n    ctx.restore();\n    return;\n  }\n  if (notRadius(radius)) {\n    return;\n  }\n  drawPointStyle(ctx, {x, y, radius, rotation, style, rad});\n}\n\nfunction drawPointStyle(ctx, {x, y, radius, rotation, style, rad}) {\n  let xOffset, yOffset, size, cornerRadius;\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n  default:\n    ctx.arc(x, y, radius, 0, TAU);\n    ctx.closePath();\n    break;\n  case 'triangle':\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      ctx.rect(x - size, y - size, 2 * size, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n    /* falls through */\n  case 'rectRot':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n    /* falls through */\n  case 'cross':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'star':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    rad += QUARTER_PI;\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'line':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n    break;\n  }\n\n  ctx.fill();\n}\n\nfunction calculateLabelSize(ctx, lines, fonts, strokeWidth) {\n  ctx.save();\n  const count = lines.length;\n  let width = 0;\n  let height = strokeWidth;\n  for (let i = 0; i < count; i++) {\n    const font = fonts[Math.min(i, fonts.length - 1)];\n    ctx.font = font.string;\n    const text = lines[i];\n    width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    height += font.lineHeight;\n  }\n  ctx.restore();\n  return {width, height};\n}\n\nfunction applyLabelDecoration(ctx, {x, y}, labels, fonts) {\n  ctx.beginPath();\n  let lhs = 0;\n  labels.forEach(function(l, i) {\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.font = f.string;\n    ctx.strokeText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n  });\n  ctx.stroke();\n}\n\nfunction applyLabelContent(ctx, {x, y}, labels, {fonts, colors}) {\n  let lhs = 0;\n  labels.forEach(function(l, i) {\n    const c = colors[Math.min(i, colors.length - 1)];\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.beginPath();\n    ctx.font = f.string;\n    ctx.fillStyle = c;\n    ctx.fillText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n    ctx.fill();\n  });\n}\n\nfunction getOpacity(value, elementValue) {\n  const opacity = isNumber(value) ? value : elementValue;\n  return isNumber(opacity) ? clamp(opacity, 0, 1) : 1;\n}\n\nconst positions = ['left', 'bottom', 'top', 'right'];\n\n/**\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\n/**\n * Drawa the callout component for labels.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {AnnotationElement} element - the label element\n */\nfunction drawCallout(ctx, element) {\n  const {pointX, pointY, options} = element;\n  const callout = options.callout;\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\n    return;\n  }\n\n  ctx.save();\n  ctx.beginPath();\n  const stroke = setBorderStyle(ctx, callout);\n  if (!stroke) {\n    return ctx.restore();\n  }\n  const {separatorStart, separatorEnd} = getCalloutSeparatorCoord(element, calloutPosition);\n  const {sideStart, sideEnd} = getCalloutSideCoord(element, calloutPosition, separatorStart);\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  const rotatedPoint = rotated({x: pointX, y: pointY}, element.getCenterPoint(), toRadians(-element.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction getCalloutSeparatorCoord(element, position) {\n  const {x, y, x2, y2} = element;\n  const adjust = getCalloutSeparatorAdjust(element, position);\n  let separatorStart, separatorEnd;\n  if (position === 'left' || position === 'right') {\n    separatorStart = {x: x + adjust, y};\n    separatorEnd = {x: separatorStart.x, y: y2};\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {x, y: y + adjust};\n    separatorEnd = {x: x2, y: separatorStart.y};\n  }\n  return {separatorStart, separatorEnd};\n}\n\nfunction getCalloutSeparatorAdjust(element, position) {\n  const {width, height, options} = element;\n  const adjust = options.callout.margin + options.borderWidth / 2;\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n  return -adjust;\n}\n\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  const {y, width, height, options} = element;\n  const start = options.callout.start;\n  const side = getCalloutSideAdjust(position, options.callout);\n  let sideStart, sideEnd;\n  if (position === 'left' || position === 'right') {\n    sideStart = {x: separatorStart.x, y: y + getSize(height, start)};\n    sideEnd = {x: sideStart.x + side, y: sideStart.y};\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {x: separatorStart.x + getSize(width, start), y: separatorStart.y};\n    sideEnd = {x: sideStart.x, y: sideStart.y + side};\n  }\n  return {sideStart, sideEnd};\n}\n\nfunction getCalloutSideAdjust(position, options) {\n  const side = options.side;\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n  return side;\n}\n\nfunction resolveCalloutPosition(element, options) {\n  const position = options.position;\n  if (positions.includes(position)) {\n    return position;\n  }\n  return resolveCalloutAutoPosition(element, options);\n}\n\nfunction resolveCalloutAutoPosition(element, options) {\n  const {x, y, x2, y2, width, height, pointX, pointY, centerX, centerY, rotation} = element;\n  const center = {x: centerX, y: centerY};\n  const start = options.start;\n  const xAdjust = getSize(width, start);\n  const yAdjust = getSize(height, start);\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\n  const yPoints = [y + yAdjust, y2, y, y2];\n  const result = [];\n  for (let index = 0; index < 4; index++) {\n    const rotatedPoint = rotated({x: xPoints[index], y: yPoints[index]}, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {x: pointX, y: pointY})\n    });\n  }\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\n}\n\nfunction isPointInRange(element, callout, position) {\n  const {pointX, pointY} = element;\n  const margin = callout.margin;\n  let x = pointX;\n  let y = pointY;\n  if (position === 'left') {\n    x += margin;\n  } else if (position === 'right') {\n    x -= margin;\n  } else if (position === 'top') {\n    y += margin;\n  } else if (position === 'bottom') {\n    y -= margin;\n  }\n  return element.inRange(x, y);\n}\n\nconst limitedLineScale = {\n  xScaleID: {min: 'xMin', max: 'xMax', start: 'left', end: 'right', startProp: 'x', endProp: 'x2'},\n  yScaleID: {min: 'yMin', max: 'yMax', start: 'bottom', end: 'top', startProp: 'y', endProp: 'y2'}\n};\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import(\"chart.js\").Point } Point\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n * @typedef { import('../../types/options').LineAnnotationOptions } LineAnnotationOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\n */\n\n/**\n * @param {Scale} scale\n * @param {number|string} value\n * @param {number} fallback\n * @returns {number}\n */\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Search the scale defined in chartjs by the axis related to the annotation options key.\n * @param {{ [key: string]: Scale }} scales\n * @param {CoreAnnotationOptions} options\n * @param {string} key\n * @returns {string}\n */\nfunction retrieveScaleID(scales, options, key) {\n  const scaleID = options[key];\n  if (scaleID || key === 'scaleID') {\n    return scaleID;\n  }\n  const axis = key.charAt(0);\n  const axes = Object.values(scales).filter((scale) => scale.axis && scale.axis === axis);\n  if (axes.length) {\n    return axes[0].id;\n  }\n  return axis;\n}\n\n/**\n * @param {Scale} scale\n * @param {{min: number, max: number, start: number, end: number}} options\n * @returns {{start: number, end: number}|undefined}\n */\nfunction getDimensionByScale(scale, options) {\n  if (scale) {\n    const reverse = scale.options.reverse;\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\n    return {\n      start,\n      end\n    };\n  }\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {Point}\n */\nfunction getChartPoint(chart, options) {\n  const {chartArea, scales} = chart;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  let x = chartArea.width / 2;\n  let y = chartArea.height / 2;\n\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\n  }\n\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\n  }\n  return {x, y};\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxProperties(chart, options) {\n  const scales = chart.scales;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n\n  if (!xScale && !yScale) {\n    return {};\n  }\n\n  let {left: x, right: x2} = xScale || chart.chartArea;\n  let {top: y, bottom: y2} = yScale || chart.chartArea;\n  const xDim = getChartDimensionByScale(xScale, {min: options.xMin, max: options.xMax, start: x, end: x2});\n  x = xDim.start;\n  x2 = xDim.end;\n  const yDim = getChartDimensionByScale(yScale, {min: options.yMin, max: options.yMax, start: y2, end: y});\n  y = yDim.start;\n  y2 = yDim.end;\n\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: x2 - x,\n    height: y2 - y,\n    centerX: x + (x2 - x) / 2,\n    centerY: y + (y2 - y) / 2\n  };\n}\n\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolvePointProperties(chart, options) {\n  if (!isBoundToPoint(options)) {\n    const box = resolveBoxProperties(chart, options);\n    let radius = options.radius;\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n    const size = radius * 2;\n    const adjustCenterX = box.centerX + options.xAdjust;\n    const adjustCenterY = box.centerY + options.yAdjust;\n    return {\n      x: adjustCenterX - radius,\n      y: adjustCenterY - radius,\n      x2: adjustCenterX + radius,\n      y2: adjustCenterY + radius,\n      centerX: adjustCenterX,\n      centerY: adjustCenterY,\n      width: size,\n      height: size,\n      radius\n    };\n  }\n  return getChartCircle(chart, options);\n}\n/**\n * @param {Chart} chart\n * @param {LineAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveLineProperties(chart, options) {\n  const {scales, chartArea} = chart;\n  const scale = scales[options.scaleID];\n  const area = {x: chartArea.left, y: chartArea.top, x2: chartArea.right, y2: chartArea.bottom};\n\n  if (scale) {\n    resolveFullLineProperties(scale, area, options);\n  } else {\n    resolveLimitedLineProperties(scales, area, options);\n  }\n  return area;\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @param {boolean} [centerBased=false]\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxAndLabelProperties(chart, options) {\n  const properties = resolveBoxProperties(chart, options);\n  properties.initProperties = initAnimationProperties(chart, properties, options);\n  properties.elements = [{\n    type: 'label',\n    optionScope: 'label',\n    properties: resolveLabelElementProperties$1(chart, properties, options),\n    initProperties: properties.initProperties\n  }];\n  return properties;\n}\n\nfunction getChartCircle(chart, options) {\n  const point = getChartPoint(chart, options);\n  const size = options.radius * 2;\n  return {\n    x: point.x - options.radius + options.xAdjust,\n    y: point.y - options.radius + options.yAdjust,\n    x2: point.x + options.radius + options.xAdjust,\n    y2: point.y + options.radius + options.yAdjust,\n    centerX: point.x + options.xAdjust,\n    centerY: point.y + options.yAdjust,\n    radius: options.radius,\n    width: size,\n    height: size\n  };\n}\n\nfunction getChartDimensionByScale(scale, options) {\n  const result = getDimensionByScale(scale, options) || options;\n  return {\n    start: Math.min(result.start, result.end),\n    end: Math.max(result.start, result.end)\n  };\n}\n\nfunction resolveFullLineProperties(scale, area, options) {\n  const min = scaleValue(scale, options.value, NaN);\n  const max = scaleValue(scale, options.endValue, min);\n  if (scale.isHorizontal()) {\n    area.x = min;\n    area.x2 = max;\n  } else {\n    area.y = min;\n    area.y2 = max;\n  }\n}\n\nfunction resolveLimitedLineProperties(scales, area, options) {\n  for (const scaleId of Object.keys(limitedLineScale)) {\n    const scale = scales[retrieveScaleID(scales, options, scaleId)];\n    if (scale) {\n      const {min, max, start, end, startProp, endProp} = limitedLineScale[scaleId];\n      const dim = getDimensionByScale(scale, {min: options[min], max: options[max], start: scale[start], end: scale[end]});\n      area[startProp] = dim.start;\n      area[endProp] = dim.end;\n    }\n  }\n}\n\nfunction calculateX({properties, options}, labelSize, position, padding) {\n  const {x: start, x2: end, width: size} = properties;\n  return calculatePosition({start, end, size, borderWidth: options.borderWidth}, {\n    position: position.x,\n    padding: {start: padding.left, end: padding.right},\n    adjust: options.label.xAdjust,\n    size: labelSize.width\n  });\n}\n\nfunction calculateY({properties, options}, labelSize, position, padding) {\n  const {y: start, y2: end, height: size} = properties;\n  return calculatePosition({start, end, size, borderWidth: options.borderWidth}, {\n    position: position.y,\n    padding: {start: padding.top, end: padding.bottom},\n    adjust: options.label.yAdjust,\n    size: labelSize.height\n  });\n}\n\nfunction calculatePosition(boxOpts, labelOpts) {\n  const {start, end, borderWidth} = boxOpts;\n  const {position, padding: {start: padStart, end: padEnd}, adjust} = labelOpts;\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\n}\n\nfunction resolveLabelElementProperties$1(chart, properties, options) {\n  const label = options.label;\n  label.backgroundColor = 'transparent';\n  label.callout.display = false;\n  const position = toPosition(label.position);\n  const padding = toPadding(label.padding);\n  const labelSize = measureLabelSize(chart.ctx, label);\n  const x = calculateX({properties, options}, labelSize, position, padding);\n  const y = calculateY({properties, options}, labelSize, position, padding);\n  const width = labelSize.width + padding.width;\n  const height = labelSize.height + padding.height;\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2,\n    rotation: label.rotation\n  };\n\n}\n\nconst moveHooks = ['enter', 'leave'];\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\nconst eventHooks = moveHooks.concat('click');\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateListeners(chart, state, options) {\n  state.listened = loadHooks(options, eventHooks, state.listeners);\n  state.moveListened = false;\n\n  moveHooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(scope => {\n      if (!state.listened && isFunction(scope.click)) {\n        state.listened = true;\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (isFunction(scope[hook])) {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {ChartEvent} event\n * @param {AnnotationPluginOptions} options\n * @return {boolean|undefined}\n */\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n    case 'mousemove':\n    case 'mouseout':\n      return handleMoveEvents(state, event, options);\n    case 'click':\n      return handleClickEvents(state, event, options);\n    }\n  }\n}\n\nfunction handleMoveEvents(state, event, options) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let elements;\n\n  if (event.type === 'mousemove') {\n    elements = getElements(state.visibleElements, event, options.interaction);\n  } else {\n    elements = [];\n  }\n\n  const previous = state.hovered;\n  state.hovered = elements;\n\n  const context = {state, event};\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\n}\n\nfunction dispatchMoveEvents({state, event}, hook, elements, checkElements) {\n  let changed;\n  for (const element of elements) {\n    if (checkElements.indexOf(element) < 0) {\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\n    }\n  }\n  return changed;\n}\n\nfunction handleClickEvents(state, event, options) {\n  const listeners = state.listeners;\n  const elements = getElements(state.visibleElements, event, options.interaction);\n  let changed;\n  for (const element of elements) {\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\n  }\n  return changed;\n}\n\nfunction dispatchEvent(handler, element, event) {\n  return callback(handler, [element.$context, event]) === true;\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst elementHooks = ['afterDraw', 'beforeDraw'];\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateHooks(chart, state, options) {\n  const visibleElements = state.visibleElements;\n  state.hooked = loadHooks(options, elementHooks, state.hooks);\n\n  if (!state.hooked) {\n    visibleElements.forEach(scope => {\n      if (!state.hooked) {\n        elementHooks.forEach(hook => {\n          if (isFunction(scope.options[hook])) {\n            state.hooked = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {AnnotationElement} element\n * @param {string} hook\n */\nfunction invokeHook(state, element, hook) {\n  if (state.hooked) {\n    const callbackHook = element.options[hook] || state.hooks[hook];\n    return callback(callbackHook, [element.$context]);\n  }\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n */\n\n/**\n * @param {Chart} chart\n * @param {Scale} scale\n * @param {CoreAnnotationOptions[]} annotations\n */\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(chart.scales, scale, annotations);\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n  if (changed && isFunction(scale.handleTickRangeOptions)) {\n    scale.handleTickRangeOptions();\n  }\n}\n\n/**\n * @param {CoreAnnotationOptions[]} annotations\n * @param {{ [key: string]: Scale }} scales\n */\nfunction verifyScaleOptions(annotations, scales) {\n  for (const annotation of annotations) {\n    verifyScaleIDs(annotation, scales);\n  }\n}\n\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    const changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\n\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\n\nfunction verifyScaleIDs(annotation, scales) {\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\n    const scaleID = retrieveScaleID(scales, annotation, key);\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\n      console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\n    }\n  }\n}\n\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n  const axis = key.charAt(0);\n  for (const prop of ['Min', 'Max', 'Value']) {\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getScaleLimits(scales, scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  const limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n    }\n  }\n  return limits;\n}\n\nfunction updateLimits(annotation, scale, props, limits) {\n  for (const prop of props) {\n    const raw = annotation[prop];\n    if (defined(raw)) {\n      const value = scale.parse(raw);\n      limits.min = Math.min(limits.min, value);\n      limits.max = Math.max(limits.max, value);\n    }\n  }\n}\n\nclass BoxAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {x, y} = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange({x, y}, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\n    drawBox(ctx, this, this.options);\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\n\nBoxAnnotation.id = 'boxAnnotation';\n\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  hitTolerance: 0,\n  label: {\n    backgroundColor: 'transparent',\n    borderWidth: 0,\n    callout: {\n      display: false\n    },\n    color: 'black',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    hitTolerance: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nclass DoughnutLabelAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    return inLabelRange(\n      {x: mouseX, y: mouseY},\n      {rect: this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), center: this.getCenterPoint(useFinalPosition)},\n      axis,\n      {rotation: this.rotation, borderWidth: 0, hitTolerance: this.options.hitTolerance}\n    );\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    if (!options.display || !options.content) {\n      return;\n    }\n    drawBackground(ctx, this);\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawLabel(ctx, this, options, this._fitRatio);\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const meta = getDatasetMeta(chart, options);\n    if (!meta) {\n      return {};\n    }\n    const {controllerMeta, point, radius} = getControllerMeta(chart, options, meta);\n    let labelSize = measureLabelSize(chart.ctx, options);\n    const _fitRatio = getFitRatio(labelSize, radius);\n    if (shouldFit(options, _fitRatio)) {\n      labelSize = {width: labelSize.width * _fitRatio, height: labelSize.height * _fitRatio};\n    }\n    const {position, xAdjust, yAdjust} = options;\n    const boxSize = measureLabelRectangle(point, labelSize, {borderWidth: 0, position, xAdjust, yAdjust});\n    return {\n      initProperties: initAnimationProperties(chart, boxSize, options),\n      ...boxSize,\n      ...controllerMeta,\n      rotation: options.rotation,\n      _fitRatio\n    };\n  }\n}\n\nDoughnutLabelAnnotation.id = 'doughnutLabelAnnotation';\n\nDoughnutLabelAnnotation.defaults = {\n  autoFit: true,\n  autoHide: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  hitTolerance: 0,\n  init: undefined,\n  opacity: undefined,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  spacing: 1,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  yAdjust: 0\n};\n\nDoughnutLabelAnnotation.defaultRoutes = {\n};\n\nfunction getDatasetMeta(chart, options) {\n  return chart.getSortedVisibleDatasetMetas().reduce(function(result, value) {\n    const controller = value.controller;\n    if (controller instanceof DoughnutController &&\n      isControllerVisible(chart, options, value.data) &&\n      (!result || controller.innerRadius < result.controller.innerRadius) &&\n      controller.options.circumference >= 90) {\n      return value;\n    }\n    return result;\n  }, undefined);\n}\n\nfunction isControllerVisible(chart, options, elements) {\n  if (!options.autoHide) {\n    return true;\n  }\n  for (let i = 0; i < elements.length; i++) {\n    if (!elements[i].hidden && chart.getDataVisibility(i)) {\n      return true;\n    }\n  }\n}\n\nfunction getControllerMeta({chartArea}, options, meta) {\n  const {left, top, right, bottom} = chartArea;\n  const {innerRadius, offsetX, offsetY} = meta.controller;\n  const x = (left + right) / 2 + offsetX;\n  const y = (top + bottom) / 2 + offsetY;\n  const square = {\n    left: Math.max(x - innerRadius, left),\n    right: Math.min(x + innerRadius, right),\n    top: Math.max(y - innerRadius, top),\n    bottom: Math.min(y + innerRadius, bottom)\n  };\n  const point = {\n    x: (square.left + square.right) / 2,\n    y: (square.top + square.bottom) / 2\n  };\n  const space = options.spacing + options.borderWidth / 2;\n  const _radius = innerRadius - space;\n  const _counterclockwise = point.y > y;\n  const side = _counterclockwise ? top + space : bottom - space;\n  const angles = getAngles(side, x, y, _radius);\n  const controllerMeta = {\n    _centerX: x,\n    _centerY: y,\n    _radius,\n    _counterclockwise,\n    ...angles\n  };\n  return {\n    controllerMeta,\n    point,\n    radius: Math.min(innerRadius, Math.min(square.right - square.left, square.bottom - square.top) / 2)\n  };\n}\n\nfunction getFitRatio({width, height}, radius) {\n  const hypo = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n  return (radius * 2) / hypo;\n}\n\nfunction getAngles(y, centerX, centerY, radius) {\n  const yk2 = Math.pow(centerY - y, 2);\n  const r2 = Math.pow(radius, 2);\n  const b = centerX * -2;\n  const c = Math.pow(centerX, 2) + yk2 - r2;\n  const delta = Math.pow(b, 2) - (4 * c);\n  if (delta <= 0) {\n    return {\n      _startAngle: 0,\n      _endAngle: TAU\n    };\n  }\n  const start = (-b - Math.sqrt(delta)) / 2;\n  const end = (-b + Math.sqrt(delta)) / 2;\n  return {\n    _startAngle: getAngleFromPoint({x: centerX, y: centerY}, {x: start, y}).angle,\n    _endAngle: getAngleFromPoint({x: centerX, y: centerY}, {x: end, y}).angle\n  };\n}\n\nfunction drawBackground(ctx, element) {\n  const {_centerX, _centerY, _radius, _startAngle, _endAngle, _counterclockwise, options} = element;\n  ctx.save();\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  ctx.arc(_centerX, _centerY, _radius, _startAngle, _endAngle, _counterclockwise);\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\nclass LabelAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    return inLabelRange(\n      {x: mouseX, y: mouseY},\n      {rect: this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), center: this.getCenterPoint(useFinalPosition)},\n      axis,\n      {rotation: this.rotation, borderWidth: this.options.borderWidth, hitTolerance: this.options.hitTolerance}\n    );\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const visible = !defined(this._visible) || this._visible;\n    if (!options.display || !options.content || !visible) {\n      return;\n    }\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawCallout(ctx, this);\n    drawBox(ctx, this, options);\n    drawLabel(ctx, getLabelSize(this), options);\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    let point;\n    if (!isBoundToPoint(options)) {\n      const {centerX, centerY} = resolveBoxProperties(chart, options);\n      point = {x: centerX, y: centerY};\n    } else {\n      point = getChartPoint(chart, options);\n    }\n    const padding = toPadding(options.padding);\n    const labelSize = measureLabelSize(chart.ctx, options);\n    const boxSize = measureLabelRectangle(point, labelSize, options, padding);\n    return {\n      initProperties: initAnimationProperties(chart, boxSize, options),\n      pointX: point.x,\n      pointY: point.y,\n      ...boxSize,\n      rotation: options.rotation\n    };\n  }\n}\n\nLabelAnnotation.id = 'labelAnnotation';\n\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    display: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%',\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  hitTolerance: 0,\n  init: undefined,\n  opacity: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction getLabelSize({x, y, width, height, options}) {\n  const hBorderWidth = options.borderWidth / 2;\n  const padding = toPadding(options.padding);\n  return {\n    x: x + padding.left + hBorderWidth,\n    y: y + padding.top + hBorderWidth,\n    width: width - padding.left - padding.right - options.borderWidth,\n    height: height - padding.top - padding.bottom - options.borderWidth\n  };\n}\n\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst sqr = v => v * v;\nconst rangeLimit = (mouseX, mouseY, {x, y, x2, y2}, axis) => axis === 'y' ? {start: Math.min(y, y2), end: Math.max(y, y2), value: mouseY} : {start: Math.min(x, x2), end: Math.max(x, x2), value: mouseX};\n// http://www.independent-software.com/determining-coordinates-on-a-html-canvas-bezier-curve.html\nconst coordInCurve = (start, cp, end, t) => (1 - t) * (1 - t) * start + 2 * (1 - t) * t * cp + t * t * end;\nconst pointInCurve = (start, cp, end, t) => ({x: coordInCurve(start.x, cp.x, end.x, t), y: coordInCurve(start.y, cp.y, end.y, t)});\nconst coordAngleInCurve = (start, cp, end, t) => 2 * (1 - t) * (cp - start) + 2 * t * (end - cp);\nconst angleInCurve = (start, cp, end, t) => -Math.atan2(coordAngleInCurve(start.x, cp.x, end.x, t), coordAngleInCurve(start.y, cp.y, end.y, t)) + 0.5 * PI;\n\nclass LineAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      const point = {mouseX, mouseY};\n      const {path, ctx} = this;\n      if (path) {\n        setBorderStyle(ctx, this.options);\n        ctx.lineWidth += this.options.hitTolerance;\n        const {chart} = this.$context;\n        const mx = mouseX * chart.currentDevicePixelRatio;\n        const my = mouseY * chart.currentDevicePixelRatio;\n        const result = ctx.isPointInStroke(path, mx, my) || isOnLabel(this, point, useFinalPosition);\n        ctx.restore();\n        return result;\n      }\n      const epsilon = sqr(hitSize);\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\n    }\n    return inAxisRange(this, {mouseX, mouseY}, axis, {hitSize, useFinalPosition});\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {x, y, x2, y2, cp, options} = this;\n\n    ctx.save();\n    if (!setBorderStyle(ctx, options)) {\n      // no border width, then line is not drawn\n      return ctx.restore();\n    }\n    setShadowStyle(ctx, options);\n\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n    if (options.curve && cp) {\n      drawCurve(ctx, this, cp, length);\n      return ctx.restore();\n    }\n    const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(this);\n    const angle = Math.atan2(y2 - y, x2 - x);\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0 + startAdjust, 0);\n    ctx.lineTo(length - endAdjust, 0);\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    const area = resolveLineProperties(chart, options);\n    const {x, y, x2, y2} = area;\n    const inside = isLineInArea(area, chart.chartArea);\n    const properties = inside\n      ? limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea)\n      : {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n    properties.centerX = (x2 + x) / 2;\n    properties.centerY = (y2 + y) / 2;\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    if (options.curve) {\n      const p1 = {x: properties.x, y: properties.y};\n      const p2 = {x: properties.x2, y: properties.y2};\n      properties.cp = getControlPoint(properties, options, distanceBetweenPoints(p1, p2));\n    }\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\n    // additonal prop to manage zoom/pan\n    labelProperties._visible = inside;\n\n    properties.elements = [{\n      type: 'label',\n      optionScope: 'label',\n      properties: labelProperties,\n      initProperties: properties.initProperties\n    }];\n    return properties;\n  }\n}\n\nLineAnnotation.id = 'lineAnnotation';\n\nconst arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  display: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\n\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    display: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  curve: false,\n  controlPoint: {\n    y: '-50%'\n  },\n  display: true,\n  endValue: undefined,\n  init: undefined,\n  hitTolerance: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\n    color: '#fff',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    hitTolerance: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\n\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction inAxisRange(element, {mouseX, mouseY}, axis, {hitSize, useFinalPosition}) {\n  const limit = rangeLimit(mouseX, mouseY, element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\n  return inLimit(limit, hitSize) || isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis);\n}\n\nfunction isLineInArea({x, y, x2, y2}, {top, right, bottom, left}) {\n  return !(\n    (x < left && x2 < left) ||\n    (x > right && x2 > right) ||\n    (y < top && y2 < top) ||\n    (y > bottom && y2 > bottom)\n  );\n}\n\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\n  if (x < left) {\n    y = interpolateY(left, {x, y}, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {x, y}, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {x, y}, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {x, y}, p2);\n    y = bottom;\n  }\n  return {x, y};\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {x, y} = limitPointToArea(p1, p2, area);\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n}\n\nfunction intersects(element, {mouseX, mouseY}, epsilon = EPSILON, useFinalPosition) {\n  // Adapted from https://stackoverflow.com/a/6853926/25507\n  const {x: x1, y: y1, x2, y2} = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lenSq = sqr(dx) + sqr(dy);\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\n\n  let xx, yy;\n  if (t < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (t > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + t * dx;\n    yy = y1 + t * dy;\n  }\n  return (sqr(mouseX - xx) + sqr(mouseY - yy)) <= epsilon;\n}\n\nfunction isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis) {\n  const label = element.label;\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\n}\n\nfunction resolveLabelElementProperties(chart, properties, options) {\n  const borderWidth = options.borderWidth;\n  const padding = toPadding(options.padding);\n  const textSize = measureLabelSize(chart.ctx, options);\n  const width = textSize.width + padding.width + borderWidth;\n  const height = textSize.height + padding.height + borderWidth;\n  return calculateLabelPosition(properties, options, {width, height, padding}, chart.chartArea);\n}\n\nfunction calculateAutoRotation(properties) {\n  const {x, y, x2, y2} = properties;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\n  const {width, height, padding} = sizes;\n  const {xAdjust, yAdjust} = label;\n  const p1 = {x: properties.x, y: properties.y};\n  const p2 = {x: properties.x2, y: properties.y2};\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(properties, label, {labelSize: size, padding}, chartArea);\n  const pt = properties.cp ? pointInCurve(p1, properties.cp, p2, t) : pointInLine(p1, p2, t);\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: padding.left};\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: padding.top};\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\n  return {\n    x: centerX - (width / 2),\n    y: centerY - (height / 2),\n    x2: centerX + (width / 2),\n    y2: centerY + (height / 2),\n    centerX,\n    centerY,\n    pointX: pt.x,\n    pointY: pt.y,\n    width,\n    height,\n    rotation: toDegrees(rotation)\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(properties, label, sizes, chartArea) {\n  let t;\n  const space = spaceAround(properties, chartArea);\n  if (label.position === 'start') {\n    t = calculateTAdjust({w: properties.x2 - properties.x, h: properties.y2 - properties.y}, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({w: properties.x - properties.x2, h: properties.y - properties.y2}, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  const {labelSize, padding} = sizes;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = (lineW > 0) && ((labelSize.w / 2 + padding.left - space.x) / lineW);\n  const y = (lineH > 0) && ((labelSize.h / 2 + padding.top - space.y) / lineH);\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(properties, chartArea) {\n  const {x, x2, y, y2} = properties;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {size, min, max, padding} = labelSizes;\n  const halfSize = size / 2;\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n  if (min >= (coordinate - padding - halfSize)) {\n    coordinate = min + padding + halfSize;\n  }\n  if (max <= (coordinate + padding + halfSize)) {\n    coordinate = max - padding - halfSize;\n  }\n  return coordinate;\n}\n\nfunction getArrowHeads(line) {\n  const options = line.options;\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\n\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return 0;\n  }\n  const {length, width} = arrowOpts;\n  const adjust = line.options.borderWidth / 2;\n  const p1 = {x: length, y: width + adjust};\n  const p2 = {x: 0, y: adjust};\n  return Math.abs(interpolateX(0, p1, p2));\n}\n\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  const {length, width, fill, backgroundColor, borderColor} = arrowOpts;\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n  ctx.stroke();\n}\n\nfunction getControlPoint(properties, options, distance) {\n  const {x, y, x2, y2, centerX, centerY} = properties;\n  const angle = Math.atan2(y2 - y, x2 - x);\n  const cp = toPosition(options.controlPoint, 0);\n  const point = {\n    x: centerX + getSize(distance, cp.x, false),\n    y: centerY + getSize(distance, cp.y, false)\n  };\n  return rotated(point, {x: centerX, y: centerY}, angle);\n}\n\nfunction drawArrowHeadOnCurve(ctx, {x, y}, {angle, adjust}, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.rotate(angle);\n  drawArrowHead(ctx, 0, -adjust, arrowOpts);\n  ctx.restore();\n}\n\nfunction drawCurve(ctx, element, cp, length) {\n  const {x, y, x2, y2, options} = element;\n  const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(element);\n  const p1 = {x, y};\n  const p2 = {x: x2, y: y2};\n  const startAngle = angleInCurve(p1, cp, p2, 0);\n  const endAngle = angleInCurve(p1, cp, p2, 1) - PI;\n  const ps = pointInCurve(p1, cp, p2, startAdjust / length);\n  const pe = pointInCurve(p1, cp, p2, 1 - endAdjust / length);\n\n  const path = new Path2D();\n  ctx.beginPath();\n  path.moveTo(ps.x, ps.y);\n  path.quadraticCurveTo(cp.x, cp.y, pe.x, pe.y);\n  ctx.shadowColor = options.borderShadowColor;\n  ctx.stroke(path);\n  element.path = path;\n  element.ctx = ctx;\n  drawArrowHeadOnCurve(ctx, ps, {angle: startAngle, adjust: startAdjust}, startOpts);\n  drawArrowHeadOnCurve(ctx, pe, {angle: endAngle, adjust: endAdjust}, endOpts);\n}\n\nclass EllipseAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const rotation = this.options.rotation;\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      return pointInEllipse({x: mouseX, y: mouseY}, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, hitSize);\n    }\n    const {x, y, x2, y2} = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n    const limit = axis === 'y' ? {start: y, end: y2} : {start: x, end: x2};\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\n    return rotatedPoint[axis] >= limit.start - hitSize - EPSILON && rotatedPoint[axis] <= limit.end + hitSize + EPSILON;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {width, height, centerX, centerY, options} = this;\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), options.rotation);\n    setShadowStyle(ctx, this.options);\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    const stroke = setBorderStyle(ctx, options);\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\n    ctx.fill();\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\n\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  label: Object.assign({}, BoxAnnotation.defaults.label),\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nEllipseAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nfunction pointInEllipse(p, ellipse, rotation, hitSize) {\n  const {width, height, centerX, centerY} = ellipse;\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n  const angle = toRadians(rotation || 0);\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\n  return (a / Math.pow(xRadius + hitSize, 2)) + (b / Math.pow(yRadius + hitSize, 2)) <= 1.0001;\n}\n\nclass PointAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {x, y, x2, y2, width} = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      return inPointRange({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), width / 2, hitSize);\n    }\n    const limit = axis === 'y' ? {start: y, end: y2, value: mouseY} : {start: x, end: x2, value: mouseX};\n    return inLimit(limit, hitSize);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const borderWidth = options.borderWidth;\n    if (options.radius < 0.1) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    drawPoint(ctx, this, this.centerX, this.centerY);\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n    options.borderWidth = borderWidth;\n  }\n\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    return properties;\n  }\n}\n\nPointAnnotation.id = 'pointAnnotation';\n\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nclass PolygonAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    if (axis !== 'x' && axis !== 'y') {\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n    }\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    const axisPoints = this.elements.map((point) => axis === 'y' ? point.bY : point.bX);\n    const start = Math.min(...axisPoints);\n    const end = Math.max(...axisPoints);\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {elements, options} = this;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    let first = true;\n    for (const el of elements) {\n      if (first) {\n        ctx.moveTo(el.x, el.y);\n        first = false;\n      } else {\n        ctx.lineTo(el.x, el.y);\n      }\n    }\n    ctx.closePath();\n    ctx.fill();\n    // If no border, don't draw it\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    const {sides, rotation} = options;\n    const elements = [];\n    const angle = (2 * PI) / sides;\n    let rad = rotation * RAD_PER_DEG;\n    for (let i = 0; i < sides; i++, rad += angle) {\n      const elProps = buildPointElement(properties, options, rad);\n      elProps.initProperties = initAnimationProperties(chart, properties, options);\n      elements.push(elProps);\n    }\n    properties.elements = elements;\n    return properties;\n  }\n}\n\nPolygonAnnotation.id = 'polygonAnnotation';\n\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction buildPointElement({centerX, centerY}, {radius, borderWidth, hitTolerance}, rad) {\n  const hitSize = (borderWidth + hitTolerance) / 2;\n  const sin = Math.sin(rad);\n  const cos = Math.cos(rad);\n  const point = {x: centerX + sin * radius, y: centerY - cos * radius};\n  return {\n    type: 'point',\n    optionScope: 'point',\n    properties: {\n      x: point.x,\n      y: point.y,\n      centerX: point.x,\n      centerY: point.y,\n      bX: centerX + sin * (radius + hitSize),\n      bY: centerY - cos * (radius + hitSize)\n    }\n  };\n}\n\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  let isInside = false;\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n  for (const point of points) {\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\n    if ((B.bY > y) !== (A.bY > y) && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n      isInside = !isInside;\n    }\n    A = B;\n  }\n  return isInside;\n}\n\nconst annotationTypes = {\n  box: BoxAnnotation,\n  doughnutLabel: DoughnutLabelAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n\n/**\n * Register fallback for annotation elements\n * For example lineAnnotation options would be looked through:\n * - the annotation object (options.plugins.annotation.annotations[id])\n * - element options (options.elements.lineAnnotation)\n * - element defaults (defaults.elements.lineAnnotation)\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\n */\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation.common'\n  });\n});\n\nconst directUpdater = {\n  update: Object.assign\n};\n\nconst hooks$1 = eventHooks.concat(elementHooks);\nconst resolve = (value, optDefs) => isObject(optDefs) ? resolveObj(value, optDefs) : value;\n\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\n/**\n * @param {string} prop\n * @returns {boolean}\n */\nconst isIndexable = (prop) => prop === 'color' || prop === 'font';\n\n/**\n * Resolve the annotation type, checking if is supported.\n * @param {string} [type=line] - annotation type\n * @returns {string} resolved annotation type\n */\nfunction resolveType(type = 'line') {\n  if (annotationTypes[type]) {\n    return type;\n  }\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\n  return 'line';\n}\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n * @param {UpdateMode} mode\n */\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotationOptions = annotations[i];\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\n    const resolver = annotationOptions.setContext(getContext(chart, element, elements, annotationOptions));\n    const properties = element.resolveElementProperties(chart, resolver);\n\n    properties.skip = toSkip(properties);\n\n    if ('elements' in properties) {\n      updateSubElements(element, properties.elements, resolver, animations);\n      // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n      delete properties.elements;\n    }\n\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n\n    Object.assign(element, properties.initProperties);\n    properties.options = resolveAnnotationOptions(resolver);\n\n    animations.update(element, properties);\n  }\n}\n\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\n\nfunction updateSubElements(mainElement, elements, resolver, animations) {\n  const subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n  for (let i = 0; i < elements.length; i++) {\n    const definition = elements[i];\n    const properties = definition.properties;\n    const subElement = getOrCreateElement(subElements, i, definition.type, definition.initProperties);\n    const subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\n\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  const elementClass = annotationTypes[resolveType(type)];\n  let element = elements[index];\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n    Object.assign(element, initProperties);\n  }\n  return element;\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elementClass = annotationTypes[resolveType(resolver.type)];\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result,\n    resolveObj(resolver, elementClass.defaults),\n    resolveObj(resolver, elementClass.defaultRoutes));\n  for (const hook of hooks$1) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const prop of Object.keys(defs)) {\n    const optDefs = defs[prop];\n    const value = resolver[prop];\n    if (isIndexable(prop) && isArray(value)) {\n      result[prop] = value.map((item) => resolve(item, optDefs));\n    } else {\n      result[prop] = resolve(value, optDefs);\n    }\n  }\n  return result;\n}\n\nfunction getContext(chart, element, elements, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    get elements() {\n      return elements.filter((el) => el && el.options);\n    },\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\n\nvar version = \"3.1.0\";\n\nconst chartStates = new Map();\nconst isNotDoughnutLabel = annotation => annotation.type !== 'doughnutLabel';\nconst hooks = eventHooks.concat(elementHooks);\n\nvar annotation = {\n  id: 'annotation',\n\n  version,\n\n  beforeRegister() {\n    requireVersion('chart.js', '4.0', Chart.version);\n  },\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false,\n      hooks: {},\n      hooked: false,\n      hovered: []\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n    verifyScaleOptions(annotations.filter(isNotDoughnutLabel), chart.scales);\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(isNotDoughnutLabel).filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\n    updateHooks(chart, state, options);\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n\n  beforeDatasetDraw(chart, _args, options) {\n    draw(chart, _args.index, options.clip);\n  },\n\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    if (handleEvent(state, args.event, options)) {\n      args.changed = true;\n    }\n  },\n\n  afterDestroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  getAnnotations(chart) {\n    const state = chartStates.get(chart);\n    return state ? state.elements : [];\n  },\n\n  // only for testing\n  _getAnnotationElementsAtEventForMode(visibleElements, event, options) {\n    return getElements(visibleElements, event, options);\n  },\n\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\n        type: 'number'\n      },\n      colors: {\n        properties: ['backgroundColor', 'borderColor'],\n        type: 'color'\n      }\n    },\n    clip: true,\n    interaction: {\n      mode: undefined,\n      axis: undefined,\n      intersect: undefined\n    },\n    common: {\n      drawTime: 'afterDatasetsDraw',\n      init: false,\n      label: {\n      }\n    }\n  },\n\n  descriptors: {\n    _indexable: false,\n    _scriptable: (prop) => !hooks.includes(prop) && prop !== 'init',\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\n    },\n    interaction: {\n      _fallback: true\n    },\n    common: {\n      label: {\n        _indexable: isIndexable,\n        _fallback: true\n      },\n      _indexable: isIndexable\n    }\n  },\n\n  additionalOptionScopes: ['']\n};\n\nfunction draw(chart, caller, clip) {\n  const {ctx, chartArea} = chart;\n  const state = chartStates.get(chart);\n\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n\n  const drawableElements = getDrawableElements(state.visibleElements, caller).sort((a, b) => a.element.options.z - b.element.options.z);\n  for (const item of drawableElements) {\n    drawElement(ctx, chartArea, state, item);\n  }\n\n  if (clip) {\n    unclipArea(ctx);\n  }\n}\n\nfunction getDrawableElements(elements, caller) {\n  const drawableElements = [];\n  for (const el of elements) {\n    if (el.options.drawTime === caller) {\n      drawableElements.push({element: el, main: true});\n    }\n    if (el.elements && el.elements.length) {\n      for (const sub of el.elements) {\n        if (sub.options.display && sub.options.drawTime === caller) {\n          drawableElements.push({element: sub});\n        }\n      }\n    }\n  }\n  return drawableElements;\n}\n\nfunction drawElement(ctx, chartArea, state, item) {\n  const el = item.element;\n  if (item.main) {\n    invokeHook(state, el, 'beforeDraw');\n    el.draw(ctx, chartArea);\n    invokeHook(state, el, 'afterDraw');\n  } else {\n    el.draw(ctx, chartArea);\n  }\n}\n\nexport { annotation as default };\n"],"names":["ChartBase","ComponentBase","extend","defaultProps","__TYPE","id","type","data","options","plugins","width","height","style","className","children","undefined","css","classes","root","inlineStyles","_ref","props","Object","assign","styles","ChartJS","Chart","_unused","PrimeReactChart","React","inProps","ref","mergeProps","useMergeProps","context","PrimeReactContext","getProps","_ChartBase$setMetaDat","setMetaData","ptm","cx","sx","isUnstyled","useHandleStyle","name","elementRef","chartRef","canvasRef","destroyChart","current","destroy","getCanvas","getChart","getBase64Image","toBase64Image","getElement","generateLegend","refresh","update","configuration","then","module","initChart","useUnmountEffect","title","text","ariaLabel","rootProps","classNames","getOtherProps","canvasProps","role","prevProps","nextProps","displayName","_excluded","_extends","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","Calendar","forwardRef","color","size","rest","xmlns","viewBox","fill","filter","Boolean","join","d","propTypes","PropTypes","ClipboardData","Google","PieChart","Speedometer2","fillRule","TextParagraph","WindowDesktop","Animator","constructor","_request","_charts","Map","_running","_lastDate","_notify","chart","anims","date","callbacks","listeners","numSteps","duration","forEach","fn","initial","currentStep","Math","min","start","_refresh","requestAnimFrame","window","_update","Date","now","remaining","running","items","item","draw","_active","_total","tick","pop","_getAnims","charts","get","complete","progress","set","listen","event","cb","push","add","has","reduce","acc","cur","max","_duration","stop","cancel","remove","delete","animator","transparent","interpolators","boolean","from","to","factor","c0","c1","valid","mix","hexString","number","Animation","cfg","prop","currentValue","resolve","_fn","_easing","effects","easing","linear","_start","floor","delay","_loop","loop","_target","_prop","_from","_to","_promises","active","elapsed","remain","wait","promises","Promise","res","rej","resolved","method","Animations","config","_chart","_properties","configure","isObject","animationOptions","defaults","animation","animatedProps","getOwnPropertyNames","option","isArray","properties","_animateOptions","values","newOptions","$shared","$animations","resolveTargetOptions","animations","_createAnimations","anim","all","awaitAll","charAt","value","scaleClip","scale","allowedOverflow","opts","reverse","end","getSortedDatasetIndices","filterVisible","metasets","_getSortedDatasetMetas","ilen","index","applyStack","stack","dsIndex","singleMode","mode","datasetIndex","otherValue","found","isNumberFinite","sign","isStacked","meta","stacked","getOrCreateStack","stacks","stackKey","indexValue","subStack","getLastIndexInStack","vScale","positive","getMatchingVisibleMetas","updateStacks","controller","parsed","_cachedMeta","_stacks","iScale","iAxis","axis","vAxis","indexScale","valueScale","getStackKey","_top","_bottom","_visualValues","getFirstScaleId","scales","shift","clearStacks","_parsed","isDirectUpdateMode","cloneIfNotShared","cached","shared","DatasetController","static","_ctx","ctx","_cachedDataOpts","getMeta","_type","_parsing","_data","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","datasetElementType","dataElementType","initialize","linkScales","_stacked","addElements","isPluginEnabled","console","warn","updateIndex","dataset","getDataset","chooseId","x","y","r","xid","xAxisID","valueOrDefault","yid","yAxisID","rid","rAxisID","indexAxis","iid","iAxisID","vid","vAxisID","xScale","getScaleForId","yScale","rScale","datasets","getDatasetMeta","scaleID","_getOtherScale","reset","_destroy","unlistenArrayEvents","_dataCheck","iAxisKey","vAxisKey","adata","Array","convertObjectDataToArray","isExtensible","listenArrayEvents","buildOrUpdateElements","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","scopes","getOptionScopes","createResolver","getContext","parsing","parse","count","sorted","_sorted","prev","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","labels","getLabels","singleScale","xAxisKey","yAxisKey","resolveObjectKey","getParsed","getDataElement","updateRangeFromParsed","range","parsedValue","NaN","getMinMax","canStack","otherScale","createStack","hidden","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","otherMin","otherMax","minDefined","maxDefined","getUserBounds","_skip","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","t","b","l","top","right","bottom","left","disabled","toClip","clip","defaultClip","elements","area","chartArea","drawActiveElementsOnTop","element","getStyle","resolveDatasetElementOptions","resolveDataElementOptions","parent","createContext","dataIndex","raw","createDataContext","createDatasetContext","_resolveElementOptions","elementType","cache","cacheKey","sharing","defined","datasetElementScopeKeys","prefixes","names","resolveNamedOptions","freeze","_resolveAnimations","transition","datasetAnimationScopeKeys","_cacheable","getSharedOptions","includeOptions","sharedOptions","_animationsDisabled","_getSharedOptions","firstOpts","previouslySharedOptions","updateSharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","move","arr","updateElements","removed","splice","_sync","args","_dataChanges","_onDataPush","_onDataPop","_onDataShift","_onDataSplice","newCount","_onDataUnshift","computeMinSampleSize","_cache","$bar","visibleMetas","concat","_arrayUnique","sort","a","getAllScaleValues","curr","_length","updateMinAndPrev","abs","getPixelForValue","ticks","getPixelForTick","parseValue","entry","startValue","endValue","barStart","barEnd","_custom","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","edge","borderSkipped","horizontal","base","borderProps","enableBorderRadius","parseEdge","orig","v1","v2","startEnd","v","setInflateAmount","ratio","inflateAmount","BarController","categoryPercentage","barPercentage","grouped","numbers","_index_","offset","grid","_value_","beginAtZero","obj","super","bars","getBasePixel","isHorizontal","ruler","_getRuler","vpixels","isNullOrUndef","head","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","center","_getStacks","last","currentParsed","iScaleValue","skipNull","find","val","isNaN","_getStackCount","_getStackIndex","pixels","barThickness","_startPixel","_endPixel","stackCount","baseValue","minBarLength","actualBase","floating","getDataVisibility","barSign","startPixel","getPixelForDecimal","endPixel","getValueForPixel","halfGrid","getLineWidthForValue","maxBarThickness","Infinity","next","percent","chunk","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","stackIndex","rects","BubbleController","radius","points","point","iPixel","vPixel","skip","DoughnutController","animateRotate","animateScale","cutout","rotation","circumference","spacing","_scriptable","_indexable","startsWith","aspectRatio","legend","generateLabels","pointStyle","map","fillStyle","backgroundColor","strokeStyle","borderColor","fontColor","lineWidth","borderWidth","onClick","e","legendItem","toggleDataVisibility","innerRadius","outerRadius","offsetX","offsetY","getter","_getRotation","toRadians","_getCircumference","_getRotationExtents","TAU","isDatasetVisible","arcs","getMaxBorderWidth","getMaxOffset","maxSize","toPercentage","chartWeight","_getRingWeight","ratioX","ratioY","startAngle","endAngle","startX","cos","startY","sin","endX","endY","calcMax","angle","_angleBetween","calcMin","maxX","maxY","HALF_PI","minX","PI","minY","getRatioAndOffset","maxWidth","maxHeight","maxRadius","toDimension","radiusLength","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","animationOpts","centerX","centerY","arc","metaData","formatNumber","locale","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","weight","LineController","showLine","spanGaps","line","_dataset","animationsDisabled","_getStartAndCountOfVisiblePoints","_scaleRangesChanged","_datasetIndex","_decimated","segment","animated","maxGapLength","isNumber","directUpdate","pointsCount","prevParsed","nullData","border","firstPoint","lastPoint","updateControlPoints","PolarAreaController","angleLines","display","circular","pointLabels","_parseObjectDataRadialScale","bind","_updateRadius","minSize","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","PieController","RadarController","_fullLoop","pointPosition","getPointPositionForValue","ScatterController","interaction","registry","abstract","Error","DateAdapterBase","override","members","init","formats","format","diff","startOf","endOf","adapters","_date","binarySearch","metaset","intersect","lookupMethod","_reversePixels","_rlookupByKey","_lookupByKey","el","getRange","lo","hi","evaluateInteractionItems","position","handler","getSortedVisibleDatasetMetas","j","getIntersectItems","useFinalPosition","includeInvisible","isPointInArea","_isPointInArea","inRange","getNearestCartesianItems","distanceMetric","useX","useY","pt1","pt2","deltaX","deltaY","sqrt","pow","getDistanceMetricForAxis","minDistance","getCenterPoint","distance","getNearestItems","getAngleFromPoint","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","getRelativePosition","nearest","STATIC_POSITIONS","filterByPosition","array","pos","filterDynamicPositionByAxis","box","sortByWeight","v0","setLayoutDims","layouts","params","wrap","stackWeight","includes","_stack","placed","buildStacks","vBoxMaxWidth","hBoxMaxHeight","layout","fullSize","availableWidth","availableHeight","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","w","heightChanged","h","same","other","getMargins","marginForPositions","positions","margin","fitBoxes","boxes","refitBoxes","refit","changed","setBoxDims","placeBoxes","userPadding","padding","addBox","_layers","z","removeBox","layoutItem","minPadding","toPadding","layoutBoxes","wrapBoxes","centerHorizontal","centerVertical","leftAndTop","rightAndBottom","vertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","each","beforeLayout","visibleVerticalBoxCount","updatePos","change","handleMaxPadding","BasePlatform","acquireContext","canvas","releaseContext","addEventListener","listener","removeEventListener","getDevicePixelRatio","getMaximumSize","isAttached","updateConfig","BasicPlatform","EXPANDO_KEY","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","supportsEventListenerOptions","passive","removeListener","nodeListContains","nodeList","node","contains","createAttachObserver","observer","MutationObserver","entries","trigger","addedNodes","removedNodes","observe","document","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","devicePixelRatio","resize","currentDevicePixelRatio","createResizeObserver","container","_getParentNode","throttled","clientWidth","ResizeObserver","contentRect","listenDevicePixelRatioChanges","releaseObserver","disconnect","unlistenDevicePixelRatioChanges","createProxyAndListen","proxy","native","fromNativeEvent","addListener","DomPlatform","renderHeight","getAttribute","renderWidth","boxSizing","displayWidth","readUsedSize","displayHeight","initCanvas","removeAttribute","setAttribute","proxies","$proxies","attach","detach","isConnected","_detectPlatform","_isDomSupported","OffscreenCanvas","Element","tooltipPosition","hasValue","final","ret","autoSkip","tickOpts","determinedMaxTicks","tickLength","_tickSize","maxScale","maxChart","_maxLength","determineMaxTicks","ticksLimit","maxTicksLimit","majorIndices","major","enabled","result","getMajorIndices","numMajorIndices","first","newTicks","ceil","skipMajors","evenMajorSpacing","len","getEvenSpacing","factors","_factorize","calculateSpacing","avgMajorSpacing","round","majorStart","majorEnd","offsetFromEdge","getTicksLimit","ticksLength","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","epsilon","lineValue","getTickMarkLength","drawTicks","getTitleHeight","fallback","font","toFont","lineHeight","titleAlign","align","_toLeftRightCenter","reverseAlign","Scale","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_dataLimitsCached","setContext","suggestedMin","suggestedMax","finiteOrDefault","metas","getTicks","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","callback","margins","grace","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","_addGrace","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","reversePixels","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","numTicks","minRotation","maxRotation","tickWidth","maxLabelDiagonal","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","_limitValue","toDegrees","asin","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","mirror","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","isFullSize","_computeLabelSizes","caches","widths","heights","jlen","tickFont","fontString","nestedLabel","widestLabelSize","highestLabelSize","_resolveTickFontOptions","string","gc","_measureText","gcLen","garbageCollect","valueAt","idx","pixel","decimal","_int16Range","_alignPixel","getDecimalForPixel","getBaseValue","createTickContext","optionTicks","rot","autoSkipPadding","_computeGridLineItems","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","positionAxisID","limit","step","optsAtIndex","optsAtIndexBorder","lineColor","borderDash","dash","borderDashOffset","dashOffset","tickColor","tickBorderDash","tickBorderDashOffset","crossAlign","tickAndPadding","hTickAndPadding","textAlign","lineCount","textOffset","textBaseline","_getXAxisLabelAlignment","_getYAxisLabelAlignment","labelOffset","halfCount","strokeColor","textStrokeColor","strokeWidth","textStrokeWidth","backdrop","tickTextAlign","showLabelBackdrop","labelPadding","backdropPadding","backdropColor","translation","_computeLabelArea","drawBackground","save","fillRect","restore","findIndex","drawGrid","drawLine","p1","p2","setLineDash","lineDashOffset","beginPath","moveTo","lineTo","stroke","drawOnChartArea","drawBorder","lastLineWidth","drawLabels","clipArea","renderTextOptions","renderText","unclipArea","drawTitle","titleX","titleY","_alignStartEnd","titleArgs","tz","gz","bz","axisID","_maxDigits","fontSize","TypedRegistry","scope","create","isForType","isPrototypeOf","register","proto","getPrototypeOf","parentScope","isIChartComponent","itemDefaults","merge","defaultRoutes","routes","property","propertyParts","split","sourceName","sourceScope","parts","targetName","targetScope","route","routeDefaults","descriptors","describe","registerDefaults","overrides","unregister","Registry","controllers","_typedRegistries","_len","_key","_each","_len2","_key2","addControllers","_len3","_key3","_len4","_key4","addPlugins","_len5","_key5","addScales","_len6","_key6","getController","_get","getPlugin","getScale","removeControllers","_len7","_key7","removeElements","_len8","_key8","removePlugins","_len9","_key9","removeScales","_len10","_key10","typedRegistry","arg","reg","_getRegistryForType","_exec","itemReg","component","camelMethod","_capitalize","PluginService","_init","notify","hook","_createDescriptors","_descriptors","descriptor","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","local","allPlugins","_ref2","getOpts","pluginOpts","createDescriptors","previousDescriptors","some","_ref3","pluginScopeKeys","scriptable","indexable","allKeys","getIndexAxis","datasetDefaults","idMatchesAxis","determineAxis","_len11","scaleOptions","_key11","toLowerCase","getAxisFromDataset","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","error","_proxy","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","mergeIf","defaultID","getAxisFromDefaultScaleID","initOptions","initData","keyCache","keysCached","Set","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","platform","clearCache","clear","datasetType","additionalOptionScopes","_cachedScopes","mainScope","resetCache","keyLists","chartOptionScopes","resolver","subPrefixes","getResolver","isScriptable","isIndexable","isFunction","hasFunction","needContext","subResolver","_attachContext","descriptorDefaults","resolverCache","_createResolver","p","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getElementById","instances","c","moveNumericKeys","intKey","getSizeForArea","field","invalidatePlugins","userConfig","initialCanvas","existingChart","uid","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","debounce","resizeDelay","_initialize","maintainAspectRatio","responsive","retinaScale","bindEvents","clearCanvas","_resizeBeforeDraw","_resize","newSize","newRatio","onResize","render","ensureScalesHaveIDs","scalesOptions","axisOptions","buildOrUpdateScales","scaleOpts","updated","isRadial","dposition","dtype","scaleType","hasUpdated","_updateMetasets","_destroyDatasetMeta","slice","_removeUnreferencedMetasets","buildOrUpdateControllers","newControllers","order","visible","ControllerClass","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","autoPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","existingEvents","newEvents","events","setsEqual","unbindEvents","changes","_getUniformDataChanges","datasetCount","makeSet","changeSet","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","useClip","getDatasetArea","getElementsAtEventForMode","setDatasetVisibility","_updateVisibility","hide","show","_stop","toDataURL","bindUserEvents","bindResponsiveEvents","_add","_remove","detached","updateHoverStyle","prefix","getActiveElements","setActiveElements","activeElements","lastActive","_ref4","_elementsEqual","pluginId","replay","hoverOptions","hover","deactivated","activated","inChartArea","eventFilter","_handleEvent","_getActiveElements","isClick","_isClickEvent","lastEvent","determineLastEvent","onHover","parseBorderRadius$1","angleDelta","o","borderRadius","_readValueToProps","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","outerStart","outerEnd","innerStart","innerEnd","rThetaToXY","theta","pathArc","pixelMargin","innerR","spacingOffset","alpha","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","closePath","fullCircles","borderJoinStyle","inner","lineJoin","angleMargin","clipArc","ArcElement","chartX","chartY","rAdjust","nonZeroBetween","betweenAngles","withinRadius","_isBetween","halfAngle","halfRadius","translate","radiusOffset","drawArc","setStyle","lineCap","borderCapStyle","previous","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","pathSegment","lineMethod","stepped","_steppedLineTo","tension","cubicInterpolationMode","_bezierCurveTo","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","Path2D","path","_path","strokePathWithCache","segments","segmentMethod","strokePathDirect","LineElement","capBezierPoints","_points","_segments","_pointsUpdated","_updateBezierControlPoints","_computeSegments","interpolate","_boundSegments","_interpolate","_steppedInterpolation","_bezierInterpolation","_pointInLine","_getInterpolationMethod","interpolated","inRange$1","hitRadius","PointElement","hoverRadius","mouseX","mouseY","inXRange","inYRange","drawPoint","getBarBounds","bar","half","skipOrLimit","boundingRects","bounds","maxW","maxH","toTRBL","parseBorderWidth","toTRBLCorners","maxR","enableBorder","topLeft","topRight","bottomLeft","bottomRight","parseBorderRadius","outer","skipX","skipY","addNormalRectPath","rect","inflateRect","amount","refRect","BarElement","addRectPath","addRoundedRectPath","BORDER_COLORS","BACKGROUND_COLORS","replace","getBorderColor","getBackgroundColor","getColorizer","colorizeDoughnutDataset","colorizePolarAreaDataset","colorizeDefaultDataset","containsColorsDefinitions","k","plugin_colors","forceOverride","_args","chartOptions","containsColorDefenition","colorizer","cleanDecimatedDataset","defineProperty","configurable","enumerable","writable","cleanDecimatedData","plugin_decimation","algorithm","beforeElementsUpdate","xAxis","pointCount","getStartAndCountOfVisiblePointsSimplified","threshold","decimated","samples","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","lttbDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","minMaxDecimation","_getBounds","_normalizeAngle","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_ref5","_pointsFromSegments","_shouldApplyFill","_resolveTarget","sources","propagate","visited","_decodeFill","fillOption","parseFillOption","parseFloat","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","unshift","pointValue","firstValue","lastValue","simpleArc","_getTarget","getLineByIndex","sourcePoints","below","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","above","clipVertical","doFill","clipY","lineLoop","tpoints","targetSegments","tgt","subBounds","fillSources","_boundSegment","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","afterDatasetsUpdate","$filler","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","itemWidth","measureText","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","col","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","adjustHitBoxes","rtl","rtlHelper","getRtlAdapter","hitbox","leftForLtr","_draw","defaultColor","halfFontSize","cursor","overrideTextDirection","textDirection","textWidth","setWidth","lineDash","drawOptions","SQRT2","xPlus","drawPointLegend","yBoxTop","xBoxLeft","drawLegendBox","_textX","strikethrough","fillText","restoreTextDirection","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","hitBox","lh","handleEvent","onLeave","isListened","hoveredItem","sameItem","itemsEqual","plugin_legend","_element","afterEvent","ci","useBorderRadius","Title","_padding","textSize","_drawArgs","fontOpts","plugin_title","titleBlock","createTitle","WeakMap","plugin_subtitle","positioners","average","xSet","eventPosition","nearestElement","distanceBetweenPoints","tp","pushOrConcat","toPush","splitNewlines","str","String","createTooltipItem","formattedValue","getTooltipSize","tooltip","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","lines","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineXAlign","yAlign","chartWidth","xAlign","caret","caretSize","caretPadding","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","cornerRadius","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","beforeTitle","noop","tooltipItems","labelCount","afterTitle","beforeLabel","tooltipItem","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","invokeCallbackWithFallback","Tooltip","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","getTitle","getBeforeBody","getBody","bodyItems","scoped","getAfterBody","getFooter","_createItems","itemSort","positionAndSize","backgroundPoint","external","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","pt","titleColor","_drawColorBox","colorX","rtlColorX","yOffSet","colorY","multiKeyBackground","outerX","innerX","strokeRect","drawBody","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","drawFooter","footerAlign","footerColor","tooltipSize","quadraticCurveTo","_updateAnimationTarget","animX","animY","_willRender","hasTooltipContent","globalAlpha","_ref6","positionChanged","_positionChanged","_ignoreReplayEvents","plugin_tooltip","afterInit","afterDraw","_fallback","findOrAddLabel","addedLabels","addIfString","lastIndexOf","_getLabelForValue","CategoryScale","_startValue","_valueRange","_addedLabels","added","isFinite","relativeLabelSize","minSpacing","_ref7","rad","LinearScaleBase","_endValue","handleTickRangeOptions","setMin","setMax","minSign","maxSign","getTickLimit","maxTicks","stepSize","computeTickLimit","generationOptions","dataRange","precision","maxDigits","includeBounds","unit","maxSpaces","rmin","rmax","countDefined","niceMin","niceMax","numSpaces","niceNum","almostWhole","almostEquals","decimalPlaces","_decimalPlaces","tickValue","generateTicks$1","_setMinAndMaxByKey","LinearScale","Ticks","formatters","numeric","log10Floor","log10","changeExponent","m","isMajor","tickVal","steps","rangeExp","rangeStep","generateTicks","_ref8","minExp","exp","startExp","significand","lastTick","LogarithmicScale","logarithmic","_zero","getTickBackdropHeight","determineLimits","fitWithPointLabels","limits","valueCount","_pointLabels","pointLabelOpts","additionalAngle","centerPointLabels","getPointLabelContext","getPointPosition","drawingArea","plFont","_longestText","updateLimits","setCenterPoint","_pointLabelItems","itemOpts","extra","createPointLabelItem","isNotOverlapped","buildPointLabelItems","hLimits","vLimits","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","RadialLinearScale","animate","leftMovement","rightMovement","topMovement","bottomMovement","angleMultiplier","scalingFactor","getValueForDistanceFromCenter","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","getBasePosition","getPointLabelPosition","drawPointLabels","gridLineOpts","drawRadiusLine","rotate","INTERVALS","millisecond","common","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","input","adapter","_adapter","parser","isoWeekday","_parseOpts","determineUnitForAutoTicks","minUnit","capacity","interval","MAX_SAFE_INTEGER","addTick","time","timestamps","_lookup","ticksFromTimestamps","majorUnit","setMajorTicks","TimeScale","displayFormats","_unit","_majorUnit","_offsets","_normalized","normalized","_applyBounds","_getLabelBounds","getLabelTimestamps","timeOpts","_generate","_filterBetween","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","initOffsets","offsetAfterAutoskip","getDecimalForValue","minor","weekday","hasWeekday","getDataTimestamps","tooltipFormat","datetime","fmt","_tickFormatFunction","formatter","minorFormat","majorFormat","offsets","_getLabelSize","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","normalize","table","prevSource","nextSource","prevTarget","nextTarget","span","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","registerables","lim","p2b","n2b","b2n","n2p","map$1","A","B","C","D","E","F","f","hex","h1","h2","eq","g","isShort","HUE_RE","hsl2rgbn","s","n","hsv2rgbn","hwb2rgbn","rgb","rgb2hsl","hueValue","calln","hsl2rgb","hue","hueParse","exec","hwb2rgb","hsv2rgb","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","nameParse","unpacked","tkeys","ok","nk","parseInt","unpack","RGB_RE","modHSL","tmp","clone","fromObject","functionParse","rgbParse","Color","hexParse","_rgb","_valid","rgbString","hslString","c2","w2","w1","rgb1","rgb2","clearer","greyscale","opaquer","negate","lighten","darken","saturate","desaturate","deg","toString","defaultValue","dimension","endsWith","thisArg","loopable","a0","a1","klen","isValidKey","_merger","tval","sval","merger","_mergerIf","keyResolvers","part","_splitKey","_getKeyResolver","toUpperCase","PITAU","INFINITY","RAD_PER_DEG","QUARTER_PI","TWO_THIRDS_PI","roundedRange","niceRange","fraction","rounded","degrees","radians","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","atan2","_angleDiff","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","cmp","mid","ti","arrayEvents","_chartjs","object","stub","requestAnimationFrame","argsToUse","ticking","timeout","clearTimeout","setTimeout","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","atEdge","elasticIn","elasticOut","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","isPatternOrGradient","getHoverColor","colors","intlCache","num","JSON","stringify","Intl","NumberFormat","getNumberFormat","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","getScope$1","Defaults","_appliers","family","hoverBackgroundColor","hoverBorderColor","hoverColor","scopeObject","targetScopeObject","privateName","defineProperties","appliers","longest","arrayOfThings","thing","nestedThing","halfWidth","resetTransform","clearRect","xOffset","yOffset","xOffsetW","yOffsetW","drawImage","ellipse","SQRT1_2","flip","midpoint","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","decorateText","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","decorationWidth","drawBackdrop","oldColor","setRenderOpts","strokeText","LINE_HEIGHT","FONT_STYLE","toLineHeight","matches","match","numberOrZero","objProps","read","toFontString","inputs","info","cacheable","minmax","keepZero","parentContext","getTarget","finalRootScopes","_resolve","Symbol","toStringTag","_scopes","_rootScopes","Proxy","deleteProperty","_keys","_cached","readKey","needsSubResolver","createSubResolver","_resolveWithPrefixes","getOwnPropertyDescriptor","Reflect","getKeysFromAllScopes","ownKeys","storage","_storage","subProxy","_context","_subProxy","receiver","getValue","_resolveScriptable","_resolveArray","_resolveWithContext","_allKeys","resolveFallback","getScope","addScopes","parentScopes","parentFallback","rootScopes","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","EPSILON","getPoint","getValueAxis","splineCurve","middlePoint","afterPoint","d01","d12","s01","s12","fa","fb","splineCurveMonotone","valueAxis","pointsLen","deltaK","mK","pointBefore","pointCurrent","pointAfter","slopeDelta","alphaK","betaK","tauK","squaredMagnitude","monotoneAdjust","monotoneCompute","capControlPoint","controlPoints","inArea","inAreaPrev","inAreaNext","domNode","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","ownerDocument","defaultView","getPositionedStyle","suffix","useOffsetPos","shadowRoot","borderBox","paddings","borders","touches","getBoundingClientRect","clientX","clientY","getCanvasPosition","round1","bbWidth","bbHeight","containerSize","containerStyle","containerBorder","containerPadding","clientHeight","getContainerSize","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","passiveSupported","getPropertyValue","cp1","cp2","getRightToLeftAdapter","rectX","getLeftToRightAdapter","_itemWidth","direction","original","getPropertyPriority","setProperty","prevTextDirection","propertyFn","between","compare","normalizeSegment","startBound","endBound","getSegment","prevValue","inside","subStart","shouldStart","shouldStop","sub","segmentOptions","findStartAndEnd","splitByStyles","solidSegments","chartContext","baseStyle","readStyle","prevStyle","addStyle","st","dir","p0","p0DataIndex","p1DataIndex","styleChanged","doSplitByStyles","replacer","visibleElements","filterElements","nearestItems","evenPoint","getPointByAxis","_index","getNearestItem","getElements","inRangeByAxis","rotated","cy","isOlderPart","act","req","clamp","inLimit","hitSize","clampAll","inBoxRange","hitTolerance","inRangeX","inRangeY","inLabelRange","getElementCenterPoint","isPercentString","toPercent","toPositivePercent","boxAppering","defaultInitAnimation","doughnutLabel","polygon","getSize","positivePercent","measureLabelRectangle","labelSize","xAdjust","yAdjust","hasPadding","positionObj","toPosition","calculateLabelPosition$1","shouldFit","fitRatio","autoFit","toFonts","optFont","fonts","isBoundToPoint","xValue","yValue","adjust","initAnimationProperties","initAnim","applyDefault","execCallback","loadHooks","hooks","hooksContainer","widthCache","fontsKey","isImageOrCanvas","content","setBorderStyle","setShadowStyle","shadowColor","backgroundShadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","measureLabelSize","mapKey","calculateLabelSize","drawBox","borderShadowColor","drawLabel","elementValue","getOpacity","optColor","calculateTextAlignment","miterLimit","setTextStrokeStyle","lhs","applyLabelDecoration","_ref9","_ref10","applyLabelContent","notRadius","drawPointStyle","drawCallout","pointX","pointY","callout","calloutPosition","xPoints","yPoints","rotatedPoint","resolveCalloutAutoPosition","resolveCalloutPosition","isPointInRange","separatorStart","separatorEnd","getCalloutSeparatorAdjust","getCalloutSeparatorCoord","sideStart","sideEnd","side","getCalloutSideAdjust","getCalloutSideCoord","limitedLineScale","xScaleID","startProp","endProp","yScaleID","scaleValue","retrieveScaleID","axes","getDimensionByScale","getChartPoint","resolveBoxProperties","xDim","getChartDimensionByScale","xMax","yDim","yMin","yMax","resolvePointProperties","adjustCenterX","adjustCenterY","getChartCircle","resolveLineProperties","resolveFullLineProperties","scaleId","dim","resolveLimitedLineProperties","resolveBoxAndLabelProperties","initProperties","optionScope","resolveLabelElementProperties$1","calculatePosition","boxOpts","padStart","padEnd","_ref11","calculateX","_ref12","calculateY","moveHooks","eventHooks","state","listened","moveListened","hovered","dispatchMoveEvents","handleMoveEvents","dispatchEvent","click","handleClickEvents","_ref13","checkElements","elementHooks","invokeHook","hooked","callbackHook","adjustScaleRange","annotations","scaleIDOption","annotation","getScaleLimits","changeScaleLimit","suggestedLimit","scaleLimitDefined","verifyScaleIDs","verifyProperties","BoxAnnotation","resolveElementProperties","DoughnutLabelAnnotation","_centerX","_centerY","_radius","_startAngle","_endAngle","_counterclockwise","_fitRatio","autoHide","isControllerVisible","controllerMeta","_ref14","square","space","angles","yk2","r2","getAngles","getControllerMeta","_ref15","hypo","getFitRatio","boxSize","LabelAnnotation","_visible","_ref16","hBorderWidth","getLabelSize","pointInLine","interpolateX","interpolateY","sqr","coordInCurve","cp","pointInCurve","coordAngleInCurve","angleInCurve","LineAnnotation","mx","my","isPointInStroke","isOnLabel","_ref24","dy","lenSq","xx","yy","intersects","_ref18","_ref19","rangeLimit","_ref17","inAxisRange","curve","startOpts","endOpts","startAdjust","endAdjust","getArrowHeads","ps","pe","drawArrowHeadOnCurve","drawCurve","drawArrowHead","_ref20","_ref21","isLineInArea","limitPointToArea","limitLineToArea","controlPoint","getControlPoint","labelProperties","sizes","calculateAutoRotation","rotatedSize","spaceAround","calculateTAdjust","calculateT","xCoordinateSizes","yCoordinateSizes","adjustLabelCoordinate","calculateLabelPosition","resolveLabelElementProperties","arrowHeadsDefaults","_ref22","_ref23","_ref25","lineSize","lineW","lineH","coordinate","halfSize","arrowStartOpts","arrowHeads","arrowEndOpts","getLineAdjust","arrowOpts","arrowOffsetX","_ref26","_ref27","EllipseAnnotation","xRadius","yRadius","cosAngle","sinAngle","pointInEllipse","PointAnnotation","inPointRange","PolygonAnnotation","isInside","bY","bX","pointIsInPolygon","axisPoints","sides","elProps","buildPointElement","_ref28","_ref29","annotationTypes","directUpdater","hooks$1","optDefs","resolveObj","resolveType","animOpts","resolveAnimations","resyncElements","annotationOptions","getOrCreateElement","toSkip","updateSubElements","resolveAnnotationOptions","mainElement","subElements","definition","subElement","elementClass","defs","chartStates","isNotDoughnutLabel","version","beforeRegister","pkg","ver","strict","requireVersion","afterRegister","afterUnregister","beforeInit","verifyScaleOptions","updateListeners","updateHooks","afterDatasetsDraw","beforeEvent","afterDestroy","getAnnotations","_getAnnotationElementsAtEventForMode","caller","drawableElements","main","getDrawableElements","drawElement"],"sourceRoot":""}